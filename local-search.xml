<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++中的enum class</title>
    <link href="/2025/06/08/cpp-enum-class/"/>
    <url>/2025/06/08/cpp-enum-class/</url>
    
    <content type="html"><![CDATA[<h2 id="与enum的对比"><a href="#与enum的对比" class="headerlink" title="与enum的对比"></a>与<code>enum</code>的对比</h2><p>C++11之所以要引入<code>enum class</code>，是因为传统的<code>enum</code></p><ul><li>作用域不限范围，会造成命名空间的污染  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;black,white,red&#125;;<span class="hljs-comment">//black、white、red作用域和color作用域相同</span><br><br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>;<span class="hljs-comment">//错误，white已经被声明过了</span><br></code></pre></td></tr></table></figure>  而<code>enum class</code>的枚举成员默认具有强作用域，需要通过枚举类型名来访问，能够降低命名空间的污染  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span>&#123;black,white,red&#125;; <span class="hljs-comment">//black、white、red作用域仅在大括号内生效</span><br><br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>;<span class="hljs-comment">//正确，这个white并不是Color中的white</span><br><br>Color c = white;<span class="hljs-comment">//错误，在作用域范围内没有white这个枚举量</span><br><br>Color c = Color::white;<span class="hljs-comment">//正确</span><br><br><span class="hljs-keyword">auto</span> c = Color::white;<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li>会发生隐式类型转换  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;black,white,red&#125;;<br><span class="hljs-function">std::vector&lt;std::<span class="hljs-type">size_t</span>&gt; <span class="hljs-title">primeFactors</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> x)</span></span>;<span class="hljs-comment">//函数返回x的质因数</span><br><br>Color c = red;<br><br><span class="hljs-keyword">if</span>(c &lt; <span class="hljs-number">14.5</span>)<span class="hljs-comment">//将color型别和double型别比较，发生隐式转换</span><br>&#123;<br>    <span class="hljs-keyword">auto</span> factors = <span class="hljs-built_in">primeFactors</span>(c);  <span class="hljs-comment">//计算一个color型别的质因数，发生隐式转换</span><br>&#125;<br></code></pre></td></tr></table></figure>  而<code>enum class</code>的元素只能通过<code>static_cast</code>进行强制类型转换</li><li>不能进行前置声明，而<code>enum class</code>可以  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>;<span class="hljs-comment">//错误</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span>;<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/weixin_42817477/article/details/109029172">[CSDN]C++11枚举类——enum class</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的const关键字</title>
    <link href="/2025/06/08/cpp-const/"/>
    <url>/2025/06/08/cpp-const/</url>
    
    <content type="html"><![CDATA[<h2 id="const关键字的使用"><a href="#const关键字的使用" class="headerlink" title="const关键字的使用"></a><code>const</code>关键字的使用</h2><p><code>const</code>关键字可以修饰C++的内置变量、指针、自定义对象、成员函数、返回值和函数参数，以告诉编译器某些值需要保持不变的。也就是说，<code>const</code>关键字是在编译过程中发挥作用的。</p><h3 id="const修饰普通类型的变量"><a href="#const修饰普通类型的变量" class="headerlink" title="const修饰普通类型的变量"></a><code>const</code>修饰普通类型的变量</h3><p>当一个变量被<code>const</code>修饰时，程序不能改变这个变量的值</p><h3 id="const修饰指针变量"><a href="#const修饰指针变量" class="headerlink" title="const修饰指针变量"></a><code>const</code>修饰指针变量</h3><p><code>const</code>修饰指针变量时，情况会变复杂，有三种情况</p><ol><li><code>const</code>修饰指针指向的内容<br>此时该指针指向的内容是不可修改的，更准确的说，是<strong>不能通过这个指针来修改它指向的内容</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p = &amp;a;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> * p = &amp;a;<span class="hljs-comment">//两种写法等价</span><br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">//错误的</span><br>a = <span class="hljs-number">9</span>;<span class="hljs-comment">//正确的</span><br></code></pre></td></tr></table></figure></li><li><code>const</code>修饰指针<br>即指针常量，指针不能修改 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;<br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span>  b = <span class="hljs-number">7</span>;<br>p = &amp;b; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure></li><li><code>const</code>修饰指针和指针指向的内容<br>则既不能通过指针修改指向的内容，也不能修改指针本身 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span>  p = &amp;a;<br></code></pre></td></tr></table></figure>为了更好地理解上述的三种情况为什么这样声明，推荐阅读<a href="https://cseweb.ucsd.edu/~gbournou/CSE131/rt_lt.rule.html">C Right-Left Rule (Rick Ord’s CSE 131</a></li></ol><h3 id="const修饰函数参数和返回值"><a href="#const修饰函数参数和返回值" class="headerlink" title="const修饰函数参数和返回值"></a><code>const</code>修饰函数参数和返回值</h3><p><code>const</code>修饰函数参数时，参数在函数体内无法被修改。最常见的情况是用<code>const</code>修饰指针防止其被意外篡改，以及<code>const</code>+引用传递以免去自定义类型在值传递时构造临时对象的开销。</p><!-- 要理清`const`修饰函数返回值对返回值的影响，首先要明白在C/C++中，函数的返回值总是**按值**返回的，函数会把返回值复制到一个外部的临时变量`a`，这个变量时可以被拷贝的。如果有在函数被调用后，有外部变量`b`能够“接住”`a`，那么`a`会被拷贝到`b`（对于自定义的变量，则会调用赋值构造函数），然后将`a`释放，如果没有变量“接住”`a`，则直接释放。接下来我们分析`const`修饰函数返回值时，三种不同的情况 --><p><code>const</code>修饰函数返回值时，有下面三种不同的情况</p><ol><li>修饰内置类型的返回值<br>返回的是一个临时变量，<code>const</code>修饰没有实际意义，与不修饰时一样</li><li>修饰自定义类型的返回值<br>则返回值不能作为左值使用，既不能被赋值也不能被修改.同时也不能调用返回对象的非<code>const</code>成员函数</li><li>修饰指针或引用类型的返回值<ul><li>函数返回指向常量的指针   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p =<span class="hljs-built_in">func</span>();<br>*p = <span class="hljs-number">10</span>;       <span class="hljs-comment">// 错误</span><br>p++; <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li>函数返回指针常量  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = <span class="hljs-built_in">func</span>();<br>*p = <span class="hljs-number">10</span>;       <span class="hljs-comment">//正确</span><br>p++;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li>函数返回指向常量的指针常量  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = <span class="hljs-built_in">func</span>();<br>*p = <span class="hljs-number">10</span>;       <span class="hljs-comment">//错误</span><br>p++;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><code>const</code>修饰引用返回值<br> 返回一个只读的引用  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> MyClass&amp; <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> MyClass&amp; ref = <span class="hljs-built_in">func</span>();<br>ref.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="const修饰类的成员函数"><a href="#const修饰类的成员函数" class="headerlink" title="const修饰类的成员函数"></a><code>const</code>修饰类的成员函数</h3><p>在成员函数的标识符后面修饰，保证在调用过程中不会修改对象中任何没有<code>mutable</code>修饰的成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> _m):_cm(_m)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_cm</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">return</span> _cm;<br>    &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _cm;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：<code>const</code>关键字不能与<code>static</code>关键字同时使用，因为<code>static</code>关键字修饰静态成员函数，静态成员函数不含有<code>this</code>指针，即不能实例化，<code>const</code>成员函数必须具体到某一实例。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><code>volatile</code>关键字</h2><p><code>volatile</code>修饰的变量表示其可以被某些编译器未知的因素修改。例如</p><ul><li>操作系统</li><li>硬件</li><li>其他的线程<br>这样编译器就不会对<code>volatile</code>修饰的变量进行优化。例如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a = i;<br>...<br><span class="hljs-comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span><br><span class="hljs-type">int</span> b = i;<br></code></pre></td></tr></table></figure><p>在上面的代码中，无论是将<code>i</code>赋值给<code>a</code>还是<code>b</code>，都要从<code>i</code>的地址中读取值，而如果<code>i</code>没有被<code>volatile</code>修饰，那么编译器就会优化对<code>b</code>的赋值，直接将上次从<code>i</code>的地址中读取的值赋值给<code>b</code>,而不是重新读取<code>i</code>的地址中的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>上面的代码也是合法的，·且<code>const</code>和<code>volatile</code>关键字都能发挥作用</p><ul><li>在<code>a</code>的作用域内，无法对<code>a</code>进行修改，因为它是<code>const</code>修饰的</li><li>但是<code>a</code>的值可能被其他线程或者别的外部事件改变，因为它是<code>volatile</code>修饰的</li></ul><h2 id="mutable关键字"><a href="#mutable关键字" class="headerlink" title="mutable关键字"></a><code>mutable</code>关键字</h2><p><code>mutable</code>关键字用于修饰类的成员变量。</p><ul><li>当成员变量被<code>mutable</code>修饰时，表示该变量时可变的，即使包含它的对象被声明为<code>const</code>类型</li><li><code>mutable</code>修饰成员变量不会影响其在类外部的可见状态</li></ul><h2 id="const与-define的区别"><a href="#const与-define的区别" class="headerlink" title="const与#define的区别"></a><code>const</code>与<code>#define</code>的区别</h2><ul><li><code>#define</code>是预处理指令，在预处理阶段对宏定义进行分析和替换，而<code>const</code>是关键字，是由编译器在编译阶段处理的</li><li><code>#define</code>没有作用域的限制（但也得在<code>#define</code>后使用啊不然就违反因果律了），宏可以被定义在当前程序的任意位置或者被其包含的头文件中，只有遇到对应的<code>#undef</code>才失效。而<code>const</code>修饰的变量有作用域的限制。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> definePI &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.1415926</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> pi = <span class="hljs-number">3.1415926</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, PI);      <span class="hljs-comment">// 输出3.1415926</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, pi);      <span class="hljs-comment">// 编译错误</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> PI</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, PI);      <span class="hljs-comment">// 编译错误</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, E);       <span class="hljs-comment">// 编译错误</span><br>&#125;<br><br><span class="hljs-keyword">namespace</span> defineE &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> E 2.7182818</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><code>#define</code>可以重定义（需要先<code>#undef</code>取消定义）但是<code>const</code>不行  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> X 30</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Y=<span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of X: &quot;</span>&lt;&lt;X&lt;&lt;endl; <span class="hljs-comment">//输出30</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> X</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> X 300</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of X: &quot;</span>&lt;&lt;X&lt;&lt;endl; <span class="hljs-comment">//输出300</span><br>    <br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of Y: &quot;</span>&lt;&lt;Y&lt;&lt;endl; <span class="hljs-comment">//输出10</span><br>    Y=<span class="hljs-number">100</span>;<span class="hljs-comment">//error, we can not assign value to const</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of Y: &quot;</span>&lt;&lt;Y&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><code>constexpr</code></h2><p><code>constexpr</code>在C++11中被引进，字面意思是<code>const expression</code>。<code>constexpr</code>修饰的变量是编译期常量，且必须用常量表达式初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mf = <span class="hljs-number">20</span>;              <span class="hljs-comment">//正确，20是常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> limit = mf + <span class="hljs-number">1</span>;       <span class="hljs-comment">//正确，mf + 1是常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> sz = <span class="hljs-built_in">size</span>();         <span class="hljs-comment">//未知，若size()函数是一个constexpr函数时即正确，反之错误。</span><br><br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> t = i;                <span class="hljs-comment">//错误，i不是常量</span><br></code></pre></td></tr></table></figure><h3 id="literal-type"><a href="#literal-type" class="headerlink" title="literal type"></a><code>literal type</code></h3><p><code>constexpr</code>只能用于修饰<code>literal type</code>的变量，一个变量是<code>literal type</code>当且仅当它属于下面的类型</p><ul><li>标量类型 <a href="https://en.cppreference.com/w/cpp/named_req/ScalarType.html">scalar type</a><br>包含<ul><li>算数类型</li><li>枚举类型</li><li>指针类型</li><li>指向类成员的指针类型</li><li><code>std::nullptr_t</code></li><li>以上类型的<code>cv</code>限定版本（即用<code>const</code>或<code>volatile</code>修饰的版本）</li></ul></li><li>引用</li><li><code>literal type</code>的数组</li><li>具有以下所有性质的<code>cv-qualified</code>类<ul><li>拥有平凡(<code>trival</code>)析构函数（即默认析构函数）（C++20前的版本）或<code>constexpr</code>析构函数(C++20)</li><li>所有非静态且非<code>variant</code>的成员（<code>variant</code>变量在编译时无法确定变量的具体类型）和基类都不是<code>volatile</code>修饰的<code>literal type</code>, 并且是下面几种类型之一<ul><li><code>lambda</code>类型</li><li>满足下列条件的聚合<code>union</code><ul><li>没有<code>variant</code>成员</li><li>或者至少有一个非<code>volatile</code>修饰的<code>literal type</code>的<code>variant</code>成员</li></ul></li><li>非<code>union</code>的聚合类型，并且每个匿名联合体成员也都满足<ul><li>没有<code>variant</code>成员</li><li>或者至少有一个非<code>volatile</code>修饰的<code>literal type</code>的<code>variant</code>成员</li></ul></li><li>具有至少一个<code>constexpr</code>构造函数的类型，且该构造函数不是拷贝或移动构造函数</li></ul></li></ul></li></ul><h3 id="与const的区别"><a href="#与const的区别" class="headerlink" title="与const的区别"></a>与<code>const</code>的区别</h3><ul><li><code>const</code>修饰的变量可以在运行时才初始化，而<code>constexpr</code>则一定会在编译期初始化。​</li><li>而<code>const</code>表示的是read only的语义，只保证修饰的变量运行时不可以被直接更改，并未区分是编译期常量还是运行期常量。​</li></ul><h3 id="constexpr指针"><a href="#constexpr指针" class="headerlink" title="constexpr指针"></a><code>constexpr</code>指针</h3><p><code>constexpr</code>只对指针本身有效，而不会对指针指向的对象生效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;            <span class="hljs-comment">//正确，p是一个指向整型常量的指针, p本身可以被修改，但是p指向的内存无法通过p来修改</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *q = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">//正确，但q是一个指向  整数  的  常量指针，q无法被修改</span><br></code></pre></td></tr></table></figure><p>一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或者<code>0</code>，或者是指向存储于某个固定地址中的对象。</p><h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a><code>constexpr</code>函数</h3><p><code>constexpr</code>修饰的函数要求其返回类型以及所有的形参都是<code>literal type</code>，且函数体中必须有且仅有一条<code>return</code>语句。这样在它们被调用时，编译期会把它们直接展开替换为结果值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<span class="hljs-comment">//constexpr函数</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> foo = <span class="hljs-built_in">new_sz</span>();<br><span class="hljs-comment">//在对变量foo初始化时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</span><br></code></pre></td></tr></table></figure><p>有意思的是，C++允许<code>constexpr</code>返回的值不是常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//如果cnt是常量表达式，则scale(cnt)也是常量表达式</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">size_t</span> cnt)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">new_sz</span>() * cnt; &#125;<br><br><span class="hljs-comment">//当scale的实参是常量表达式时，它的表达式也是常量表达式，反之则不然</span><br><span class="hljs-type">int</span> arr[<span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>)];<span class="hljs-comment">//正确：scale(2)是常量表达式</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<span class="hljs-comment">//i不是常量表达式</span><br><span class="hljs-type">int</span> a2[<span class="hljs-built_in">scale</span>(i)];<span class="hljs-comment">//错误：scale(i)不是常量表达式</span><br></code></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>数组大小、模板参数和<code>switch</code>语句都要求编译期常量，使用<code>constexpr</code>修饰的变量或函数可以用于这些场景。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cn = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> arr[n]; <span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span> arr[cn]; <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">[RUNOOB] C++ const 关键字小结</a></li><li><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">[RUNOOB] C&#x2F;C++ 中 volatile 关键字详解</a></li><li><a href="https://en.cppreference.com/w/cpp/keyword/const.html">[cppreference.com] C++ keyword: const</a></li><li><a href="https://en.cppreference.com/w/cpp/language/cv.html">[cppreference.com] cv (const and volatile) type qualifiers</a></li><li><a href="https://en.cppreference.com/w/cpp/keyword/volatile.html">[cppreference.com] C++ keyword: volatile</a></li><li><a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">[cppreference.com] C++ named requirements: LiteralType (since C++11)</a></li><li><a href="https://www.cnblogs.com/ljwgis/p/13095739.html">[cnblog] C++11新特性：constexpr变量和constexpr函数</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的inline关键字</title>
    <link href="/2025/06/08/cpp-inline/"/>
    <url>/2025/06/08/cpp-inline/</url>
    
    <content type="html"><![CDATA[<p><code>inline</code>关键字会向编译器发出一个请求（而非命令，编译器可以选择拒绝），建议将函数体在调用点处内联展开，以减少函数的调用开销（例如栈帧的创建、参数的传递等）。</p><ul><li><code>inline</code>函数通常用于执行速度快且调用频繁的小函数</li><li><code>inline</code>函数的定义通常放在头文件中</li><li><code>inline</code>函数不能包含复杂的控制结构，例如循环和递归</li><li>编译器可能会忽略<code>inline</code>关键字，一般是<ul><li>函数体较大</li><li>包含复杂逻辑</li><li>编译器的优化级别较低，在编译时比较保守</li><li>编译器的优化策略决定</li></ul></li><li>可以通过在汇编代码查看代码是否内联，被内联的函数不会有函数标签</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的内存管理</title>
    <link href="/2025/06/07/memory/"/>
    <url>/2025/06/07/memory/</url>
    
    <content type="html"><![CDATA[<h2 id="内存的分类"><a href="#内存的分类" class="headerlink" title="内存的分类"></a>内存的分类</h2><h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>栈内存是由<strong>编译器自动管理</strong>的内存区域，用于存储局部变量、函数参数和返回地址等。栈内存的分配和释放是自动进行的：</p><ul><li>当函数被调用时，局部变量和参数会被压入栈中</li><li>当函数返回时，这些局部变量和参数会被弹出栈并释放。<br>栈内存的大小固定，一般为8M左右，无法动态调整。作用域一般是函数内部，函数返回时会自动释放。</li></ul><p>分配速度快。</p><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>栈溢出最典型的情况就是无限递归调用导致溢出，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 无限递归调用</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h4><p>在函数调用过程中，当前函数执行完成后应返回调用者的位置，这个位置称之为返回地址。</p><h4 id="栈攻击"><a href="#栈攻击" class="headerlink" title="栈攻击"></a>栈攻击</h4><ol><li>返回地址重写<br>攻击者向固定大小的缓冲区写入超长的数据，覆盖返回地址，使程序跳转到恶意代码</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vulnerable</span><span class="hljs-params">(<span class="hljs-type">char</span> *input)</span> </span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">16</span>];<br>    <span class="hljs-built_in">strcpy</span>(buf, input); <span class="hljs-comment">// 无边界检查,如果输入超过16字节，就可能覆盖返回地址，跳转到攻击者布置的shellcode。</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li></li></ol><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>堆内存是由程序员手动管理的内存区域。大小不固定，可以动态调整，但任意出现内存泄露等问题。</p><p>作用域由程序员控制，只要不释放内存就一直存在。</p><p>分配速度较慢。</p><h2 id="变量和存储区"><a href="#变量和存储区" class="headerlink" title="变量和存储区"></a>变量和存储区</h2><img src="/2025/06/07/memory/memory.jpg" class="" title="C++的内存分区"><p>c++程序的内存分为4个区域</p><ul><li><strong>代码段</strong> 存储代码的指令，只读</li><li><strong>数据段</strong><br>存储<strong>全局变量</strong>和<strong>静态变量</strong>，分为 <ul><li><p>已初始化的数据区<br>进一步分为</p><ul><li>已初始化的只读区域<br>存储<code>const</code>修饰的全局变量、常量字符串等，例如<code>const char* str = &quot;hello world&quot;</code>这行代码中<code>&quot;hello world&quot;</code>存储在已初始化的只读区域，<code>str</code>放在已初始化的读写区域(注意<code>const char* str</code>是 “指向常量的指针”，所以它<code>str</code>还可以修改，只是不能通过它去修改指向的内容。)</li><li>已初始化的读写区域</li></ul></li><li><p>未初始化的数据区（Block Started by Symbol，BSS）<br>存储未初始化或初始化为0的全局变量和静态变量</p></li></ul></li><li><strong>堆区</strong></li><li><strong>栈区</strong></li></ul><h2 id="堆内存的使用"><a href="#堆内存的使用" class="headerlink" title="堆内存的使用"></a>堆内存的使用</h2><ul><li><a href="https://en.cppreference.com/w/cpp/memory/c/malloc">std::malloc</a><br>用于在堆上分配指定大小的内存块  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure>返回指向分配的内存的指针，若分配失败，则返回<code>nullptr</code></li><li><code>calloc</code><br>分配内存并初始化（将所有的字节都置0）   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num, <span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure><ul><li><code>num</code>要分配的元素的个数</li><li><code>size</code>元素的大小（字节数）</li></ul></li><li><code>realloc</code><br>调整已分配的内存块的大小   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure><ul><li><code>ptr</code>要调整的内存块的指针</li><li><code>size</code>新的内存块大小（字节数）</li><li>返回指向新的内存块的指针，若分配失败，返回<code>nullptr</code>，原来的内存块（<code>ptr</code>）保持原样。<ul><li><p>分配失败可能会导致内存泄露</p><blockquote><p>If there is not enough memory, the old memory block is not freed and null pointer is returned.——<a href="https://en.cppreference.com/w/c/memory/realloc">cppreference</a></p></blockquote><p>需要手动处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">        <span class="hljs-type">int</span>* ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>`(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);​<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>) &#123;​<br>    <span class="hljs-comment">// 处理内存分配失败​</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 或采取其他错误处理​</span><br>&#125;​<br>​<br><span class="hljs-comment">// 使用临时指针保存realloc结果​</span><br><span class="hljs-type">int</span>* temp = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(ptr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">20</span>);​<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;​<br>    <span class="hljs-comment">// realloc失败：原始内存仍可通过ptr访问​</span><br>    <span class="hljs-built_in">free</span>(ptr);   <span class="hljs-comment">// 释放原始内存（可选）​</span><br>    ptr = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 避免悬空指针​</span><br>    <span class="hljs-comment">// 处理错误（例如退出或降级使用）​</span><br>&#125; <span class="hljs-keyword">else</span> &#123;​<br>    ptr = temp; <span class="hljs-comment">// realloc成功，更新ptr​</span><br>    <span class="hljs-comment">// 现在ptr指向20个int的内存​</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><code>free</code><br>释放通过<code>malloc</code>,<code>calloc</code>和<code>realloc</code>分配的内存空间  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢"><a href="#为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢" class="headerlink" title="为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢?"></a>为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢?</h3><p>因为<code>malloc(size)</code>在分配内存时，除了会分配一部分大小为<code>size</code>的内存供程序员使用外，还会在这部分内存头部添加这块内存的元数据，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mem_control_block</span> &#123;<br>  <span class="hljs-type">int</span> is_available; <br>  <span class="hljs-type">int</span> size;        <br>&#125;;<br></code></pre></td></tr></table></figure><p>这样<code>free</code>这块内存的时候就可以访问这块区域进而获取需要free的内存大小。</p><!-- ### malloc的底层实现 -->]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的指针</title>
    <link href="/2025/06/06/cpp-pointer/"/>
    <url>/2025/06/06/cpp-pointer/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>指针本质上也是一种变量，不过它存储的是对应变量类型的地址。</p><h3 id="为什么要有指针"><a href="#为什么要有指针" class="headerlink" title="为什么要有指针"></a>为什么要有指针</h3><!-- 笔者在学习指针时，一直有一个疑惑，那就是变量本身就包含地址，那为什么还需要指针呢？想来如果解释了这个问题，就解释了指针在C++中发挥的作用。* 首先, 我们拿到地址后，我们可以用地址做什么？  * 修改这个地址对应内存的值  似乎有些脱裤子放屁了，用变量本身就可以做到  * 对于一些很大的变量（类和结构体），值传递会有很大的复制开销，我们可以通过传递地址来减少这部分开销。  * 我们可以通过地址，访问邻近的变量*  --><p>之所以要有指针，是因为虽然变量本身就包含了地址的信息（不然我们也没法通过<code>&amp;</code>来取址），但变量和其地址之间的关系是一一对应的且无法修改的，无法满足我们对地址本身进行处理的需求。例如如果我们要实现数组的数据结构，将数据放入连续的内存中，那么我们需要解决下面的问题</p><ol><li>这块连续内存的起始地址是什么？</li><li>访问数组中的某个元素时，我们该如何确定它的地址？<br>假如这个元素的索引是<code>i</code>，数组中的元素大小都是<code>T</code>，那么我们访问它的时候就需要通过<code>首地址+i*T</code>来获取它的地址。</li></ol><p>那么问题来了，地址本身是个整型数据，为什么我们不直接使用<code>int</code>等整型类型来存储和操作呢？</p><ul><li>首先，需要维护一个额外的变量来告诉我们这个地址对应的变量大小，否则我们没法对这个地址取值，也没办法进行前面提到的数组寻址操作</li><li>其次，这样写的代码可读性很差</li><li>再者，不同平台的地址大小不同，如果我们在32位系统中使用<code>int</code>来存储地址，那么这部分代码就无法在64位的系统中运行<br>因此，定义一种新的变量来存储和操作地址是很有必要的。</li></ul><h3 id="指针的基本操作"><a href="#指针的基本操作" class="headerlink" title="指针的基本操作"></a>指针的基本操作</h3><ul><li>赋值和初始化  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p = &amp;a; <br></code></pre></td></tr></table></figure></li><li>解引用<br>指针通过<code>*</code>操作符获取指向的内存中存储的值，值的类型由指针的类型确定</li><li>指针运算<ul><li>加减运算<ul><li><code>T*</code>类型的指针<code>p + i</code>相当于<code>p</code>向前移动了<code>i * sizeof(T)</code>个字节</li><li>支持<code>++</code>和<code>--</code></li></ul></li><li>比较运算<br>比较两个指针的值，也就是比较两个地址是否相同</li></ul></li></ul><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>数组名本质是指向数组首地址的、<strong>不可修改</strong>的常量指针。在作为函数参数时，它会退化为指向数组首元素的指针，这时候可以对它进行自增等运算。</p><ul><li><code>int (*p)[10]</code>表示这是一个指向长度为10的<code>int</code>数组的指针，其类型为<code>int (*)[]</code>。也就是说<code>p++</code>会令<code>p</code>向前移动40个字节</li><li><code>int *p[10]</code>表示这是一个包含了10个<code>int*</code>变量的数组。作为函数参数退化为指针后，它的类型是<code>int**</code></li></ul><!-- ### 指针与动态数组 --><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>每个函数都有一个唯一的入口地址，函数指针存储的就是这个地址。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//返回类型 (*指针名)(函数参数列表);</span><br><span class="hljs-built_in">int</span> (*funcPtr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>这里的<code>funcPtr</code>就是一个指向函数的指针，接受两个<code>int</code>参数并返回<code>int</code>值。</p><h3 id="赋值与调用"><a href="#赋值与调用" class="headerlink" title="赋值与调用"></a>赋值与调用</h3><ul><li>函数名在大多数情况下都会被编译器解释为函数的地址，因此可以直接用函数名给函数指针赋值。</li><li>函数指针的调用方式与函数名的调用方式一致</li><li>基于提高可读性的目的，可以使用<code>typedef</code>来封装函数指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;​<br>    <span class="hljs-keyword">return</span> a + b;​<br>&#125;​<br>​<br><span class="hljs-comment">// 封装后的函数指针类型​</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*FuncPtr)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-comment">// 声明一个函数指针变量​</span><br>    FuncPtr fp = add;​<br>​<br>    <span class="hljs-comment">// 通过函数指针调用函数​</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">fp</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);​<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result: %d\n&quot;</span>, result);  <span class="hljs-comment">// 输出: Result: 7​</span><br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>指针函数是返回指针的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>注意和函数指针的区别在于是否有括号将*+标识符包裹起来，关于C&#x2F;C++中的声明规则，可以阅读<a href="https://cseweb.ucsd.edu/~gbournou/CSE131/rt_lt.rule.html">C Right-Left Rule (Rick Ord’s CSE 131</a></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>通过回调函数，程序在运行时可以动态地决定调用哪个函数。这常常用于事件处理和异步编程的场景中，例如GUI编程中的按钮和ROS中对topic的订阅都会绑定对应的回调函数。在C语言中，回调函数通过函数指针来实现。</p><h4 id="回调函数的实现"><a href="#回调函数的实现" class="headerlink" title="回调函数的实现"></a>回调函数的实现</h4><ol><li>设计包含回调函数参数的函数接口</li><li>调用1.中的函数并传递合适的回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, FuncPtr callback)</span> </span>&#123;​<br>    <span class="hljs-comment">// ... 执行一些操作 ...​</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">callback</span>(x, y);​<br>    <span class="hljs-comment">// ... 使用回调函数的返回值进行进一步处理 ...​</span><br>&#125;​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, add);​ <span class="hljs-comment">//可以传递div,multi等等函数，只要函数的参数和返回值与函数指针一致即可</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><!-- ## 指针与内存管理https://lb3fn675fh.feishu.cn/wiki/OVsewICczis2jlkKBgKc3Mz9n8d## 指针与高级数据类型https://lb3fn675fh.feishu.cn/wiki/QlEJwXrH4i9MxPkS1OncaPX4nze## 指针与常量https://lb3fn675fh.feishu.cn/wiki/WcSrwytf5ivjkQkWd86cEJnxnph --><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>避免野指针：始终确保指针在使用前已经正确初始化，并且在不再需要时将其设置为<code>nullptr</code>。</li><li>避免内存泄漏：动态分配的内存在使用完毕后一定要使用<code>free</code>释放。</li><li>有效性检查：在解引用前检查它是否是<code>nullptr</code>。</li><li>使用智能指针：C++11引入的智能指针可以自动管理内存，减少内存泄露的风险。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
