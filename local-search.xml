<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++中的继承与多态</title>
    <link href="/2025/06/14/cpp-inheritance/"/>
    <url>/2025/06/14/cpp-inheritance/</url>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>C++中的类可以通过继承别的类来定义，这能够大幅提高代码的复用效率。继承的语法为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">newClass</span> : 访问修饰符 baseClass&#123;&#125;;<br></code></pre></td></tr></table></figure><p>根据访问修饰符，类的继承分为</p><ul><li>公有继承  不改变基类中成员的访问属性</li><li>保护继承 将基类的<code>public</code>和<code>protected</code>成员都变成<code>protected</code></li><li>私有继承 将基类的<code>public</code>和<code>protected</code>成员都变成<code>private</code></li></ul><h3 id="构造函数和析构函数的调用顺序"><a href="#构造函数和析构函数的调用顺序" class="headerlink" title="构造函数和析构函数的调用顺序"></a>构造函数和析构函数的调用顺序</h3><ul><li>构造函数的调用顺序：<strong>自上而下</strong><br>当建立一个对象时，<strong>首先调用基类</strong>的构造函数，然后调用下一个派生类的构造函数，依次类推，直至到达最底层目标派生类的构造函数</li><li>析构函数的调用顺序：<strong>自下而上</strong><br>当删除一个对象时，<strong>首先调用该派生类</strong>的析构函数，然后调用上一层基类的析构函数，依次类推，直到到达最顶层的基类析构函数</li></ul><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>C++中一个子类可以继承多个父类。比如一个男子篮球运动员，那就可以定义两个父类，一个<code>MalePeople</code>类，一个<code>BasketballPlayer</code>类，那如果想要定义男子篮球运动员类，可以定义一个<code>MaleBasketballPlayer</code>类，继承<code>MalePeople</code>和<code>BaskeballPlayer</code>，代码如下：​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MalePeople</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MalePeople Speak \n&quot;</span>; &#125;​<br>&#125;;​<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasketBallPlayer</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Play</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Play Basketball \n&quot;</span>; &#125;​<br>&#125;;​<br>​<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaleBasketBallPlayer</span> : <span class="hljs-keyword">public</span> MalePeople, <span class="hljs-keyword">public</span> BasketBallPlayer &#123;&#125;;​<br></code></pre></td></tr></table></figure><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><pre><code class=" mermaid">graph TB  A1[&quot;A&quot;]  A2[&quot;A&quot;]  %% 从它们向下连线  A1 --&gt; B[&quot;B&quot;]  A2 --&gt; C[&quot;C&quot;]  %% 最后合并到 D  B  --&gt; D[&quot;D&quot;]  C  --&gt; D</code></pre><p>当一个类使用普通的继承来继承两个父类，而这两个父类存在一样的父类,如上图所示，那么D中就会存储两份A的数据，造成内存的浪费。此外，还会导致二义性，当D调用A的方法时，由于有两个A，编译器也无法判断调用哪个方法。为了解决这个问题，可以采用<strong>虚继承</strong>。</p><pre><code class=" mermaid">graph TB  A --&gt; B[&quot;B&quot;]  A --&gt; C[&quot;C&quot;]  %% 最后合并到 D  B  --&gt; D[&quot;D&quot;]  C  --&gt; D</code></pre><p>使用虚继承时，只有一个共享的基类被继承了。<br>使用虚继承只需要在继承时添加<code>virtual</code>进行修饰即可,注意是在<code>B</code>和<code>C</code>继承<code>A</code>时用<code>virtual</code>进行修饰而不是<code>D</code>继承<code>B</code>和<code>C</code>时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123;​<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Base Func\n&quot;</span>); &#125;​<br>&#125;;​<br>​<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BaseA</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base &#123;​<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;BaseA Func\n&quot;</span>); &#125;​<br>&#125;;​<br>​<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BaseB</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Base &#123;​<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;BaseB Func\n&quot;</span>); &#125;​<br>&#125;;​<br>​<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> BaseB, <span class="hljs-keyword">public</span> BaseA &#123;​<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Derive Func \n&quot;</span>); &#125;​<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指同一个接口，在不同的对象调用时，根据对象的类型来执行不同的内容，产生不同的行为。例如男人和女人都能调用<code>说话</code>这一接口，但是他们说话的音色语调等特性都不相同。</p><h3 id="虚函数与多态"><a href="#虚函数与多态" class="headerlink" title="虚函数与多态"></a>虚函数与多态</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;People Speak \n&quot;</span>; &#125;​<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的代码中<code>Speak()</code>用<code>virtual</code>进行修饰，表示这是一个虚函数，虚函数可以被派生类所覆盖。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MalePeople</span> : <span class="hljs-keyword">public</span> People &#123;​<br><span class="hljs-keyword">public</span>:​<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;MalePeople Speak \n&quot;</span>; &#125;​<br>&#125;;​<br>​<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FemalePeople</span> : <span class="hljs-keyword">public</span> People &#123;​<br><span class="hljs-keyword">public</span>:​<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;FemalePeople Speak \n&quot;</span>; &#125;​<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>MalePeople</code>和<code>FemalePeople</code>继承了<code>People</code>类并将虚函数覆盖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    People *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">People</span>();​<br>    People *p2 = <span class="hljs-built_in">static_cast</span>&lt;People *&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MalePeople</span>());​<br>    People *p3 = <span class="hljs-built_in">static_cast</span>&lt;People *&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">FemalePeople</span>());​<br>    <br>    p1-&gt;<span class="hljs-built_in">Speak</span>(); <span class="hljs-comment">// People Speak​</span><br>    p2-&gt;<span class="hljs-built_in">Speak</span>(); <span class="hljs-comment">// MalePeople Speak​</span><br>    p3-&gt;<span class="hljs-built_in">Speak</span>(); <span class="hljs-comment">// FemalePeople Speak​</span><br>    <span class="hljs-keyword">delete</span> p3;​<br>    <span class="hljs-keyword">delete</span> p2;​<br>    <span class="hljs-keyword">delete</span> p1;​<br>&#125;<br></code></pre></td></tr></table></figure><p><code>p1</code>,<code>p2</code>和<code>p3</code>都是<code>People</code>类的指针，调用的也都是相同的函数<code>Speak()</code>,但是由于指向的具体实例不同，产生了不同的行为，这就是多态。<br>多态同样可以通过基类的引用来实现。<br>需要注意的是</p><ul><li>虚函数的重写要求函数名、函数参数与返回值都相同</li><li>重写只对虚函数的函数体有效，返回值类型、函数名、参数列表和缺省参数都不能修改</li><li>多态必须要满足两个条件<ul><li>虚函数的重写</li><li>用父类类型的指针或引用(接收父类对象或子类对象)的对象去调用虚函数</li></ul></li></ul><h3 id="多态的原理"><a href="#多态的原理" class="headerlink" title="多态的原理"></a>多态的原理</h3><p>多态的关键在于通过基类指针或引用调用一个虚函数时，编译时不能确定到底调用的是基类还是派生类的函数，运行时才能确定。</p><h4 id="1-虚函数表指针（vptr）"><a href="#1-虚函数表指针（vptr）" class="headerlink" title="1. 虚函数表指针（vptr）"></a>1. 虚函数表指针（vptr）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; &#125; <span class="hljs-comment">// 虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123; &#125; <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(A) &lt;&lt; <span class="hljs-string">&quot;,&quot;</span>&lt;&lt; <span class="hljs-built_in">sizeof</span>(B);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在64位的设备上运行上面的代码，结果是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">16</span>,<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>说明包含虚函数的类会多出8个字节的大小，实际上这8个字节存放的就是指向虚函数表的指针，也就是虚函数表的地址。</p><h4 id="2-虚函数表（vtable）"><a href="#2-虚函数表（vtable）" class="headerlink" title="2. 虚函数表（vtable）"></a>2. 虚函数表（vtable）</h4><p>每一个包含虚函数的<strong>类</strong>，都有一个<strong>虚函数表（vtable）</strong>，虚函数表会列出这个类中虚函数的地址。这个类的所有<strong>实例</strong>中都存放着<strong>指向这个虚函数表的指针</strong>。</p><p><strong>虚函数表</strong>本质上一是一个虚函数指针数组，元素的顺序取决于虚函数声明的顺序。它有以下性质</p><ul><li>虚函数表在编译期间生成，构造对象时初始化的是虚函数表指针</li><li>虚函数继承体系中,基类先生成一份虚表,之后派生类自己的虚表都是基于从父类继承下来的虚表</li><li>如果派生类重写了基类中某个虚函数，会在虚函数表内用派生类自己的虚函数地址覆盖虚表中基类的虚函数地址,如果子类没有重写,则虚函数表和父类的虚函数表的元素完全一样</li><li>派生类自己新增加的虚函数,从继承的虚表的最后一个元素开始,按其在派生类中的声明次序增加到派生类虚表的最后。</li><li>虚函数和普通函数一样的，都是存在代码段的，只是他的指针又存到了虚表中</li><li>同一类的对象共享一个虚函数表</li></ul><h4 id="3-多态的实现机制"><a href="#3-多态的实现机制" class="headerlink" title="3. 多态的实现机制"></a>3. 多态的实现机制</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    People *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">People</span>();​<br>    People *p2 = <span class="hljs-built_in">static_cast</span>&lt;People *&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MalePeople</span>());​<br>    People *p3 = <span class="hljs-built_in">static_cast</span>&lt;People *&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">FemalePeople</span>());​<br>    <br>    p1-&gt;<span class="hljs-built_in">Speak</span>(); <span class="hljs-comment">// People Speak​</span><br>    p2-&gt;<span class="hljs-built_in">Speak</span>(); <span class="hljs-comment">// MalePeople Speak​</span><br>    p3-&gt;<span class="hljs-built_in">Speak</span>(); <span class="hljs-comment">// FemalePeople Speak​</span><br>    <span class="hljs-keyword">delete</span> p3;​<br>    <span class="hljs-keyword">delete</span> p2;​<br>    <span class="hljs-keyword">delete</span> p1;​<br>&#125;<br></code></pre></td></tr></table></figure><p>在编译时，如果<code>Speak()</code>不是虚函数，那么编译器会直接将其绑定到固定的函数地址，但由于<code>Speak()</code>被声明为<code>virtual</code>，那么编译器会将基类指针对其的调用编译为两步</p><ol><li>通过基类指针读取虚函数表指针，如果此时基类指针指向的是派生类，那么读取的就是指向派生类虚函数表的指针</li><li>根据<code>Speak()</code>声明的顺序（也就是其在虚函数表中的偏移），用虚函数表指针读取它真正的函数地址</li><li>通过第2步读取的函数地址，调用对应的函数</li></ol><p>根据上面的内容，我们发现通过虚函数实现多态时，函数的地址是在运行时才被绑定的，因此这种多态的实现也叫做<strong>运行时多态</strong>和<strong>动态多态</strong></p><!-- #### 早绑定### 运行时多态和编译时多态我们称通过虚函数实现的多态为**运行时多态**，也叫动态多态，这是因为 --><h3 id="纯虚函数与抽象类"><a href="#纯虚函数与抽象类" class="headerlink" title="纯虚函数与抽象类"></a>纯虚函数与抽象类</h3><p>纯虚函数是在虚函数的基础上用<code>=0</code>修饰</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>含有纯虚函数的类叫做抽象类，抽象类不允许被实例化，只能通过派生来来实例化。</p><h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><p>在多态的情景下，如果析构函数不是虚函数，那么通过基类的指针删除派生类对象时，只会调用基类的析构函数，而不会调用派生类的析构函数，那么可能会导致派生类的资源没有释放，造成内存泄漏。</p><p>因此在实现多态时，需要将基类的析构函数设置为虚函数。</p><p>需要注意的是，<strong>构造函数不能声明为虚函数</strong>，因为虚函数机制依赖于对象的 <code>vtable</code> 指针，而 <code>vtable</code> 指针是在基类构造完成之后才会被设置的。在调用构造函数的过程中，对象还未完全构建，虚表还未就绪，因此无法调用“动态绑定”的虚函数。</p><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a><code>final</code>关键字</h3><p><code>final</code>是C++11中引入的关键字，用于修饰类和类中的虚函数。</p><ul><li>用<code>final</code>修饰类时，禁止该类被继承，继承该类会导致编译错误。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">final</span><br>&#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A <span class="hljs-comment">//编译错误</span><br>&#123;&#125;;<br></code></pre></td></tr></table></figure></li><li><code>final</code>关键字还可以标记虚函数，从而禁止子类中重写该函数  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">final</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-comment">//编译错误</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="override关键字"><a href="#override关键字" class="headerlink" title="override关键字"></a><code>override</code>关键字</h3><p>如果某些情况因为疏忽而导致函数没有进行重写,这种情况在编译期间是不会报错的,只有程序运行时没有得到预期结果才可能意识到出现了问题,等到这时再debug已经得不偿失了。</p><p>因此C++11引入了<code>override</code>关键字，如果被<code>override</code>关键字修饰的派生类虚函数没有重写，则无法通过编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>     <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>  </span>&#123;&#125;<br>&#125;;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">override</span></span>&#123; &#125; <span class="hljs-comment">//error</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/DSCL-ing/p/18240152">[cnblog.com] 深入剖析C++多态的实现与原理-详解 </a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RAII</title>
    <link href="/2025/06/13/cpp-RAII/"/>
    <url>/2025/06/13/cpp-RAII/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是RAII"><a href="#什么是RAII" class="headerlink" title="什么是RAII"></a>什么是<code>RAII</code></h2><p><code>RAII</code>，<code>Resource Acquisition Is Initialization</code>,资源获取即初始化，是C++中很重要的编程思想，它将资源的声明周期和对象的生命周期绑定到一起，在构造函数请求资源，在析构函数释放资源并且绝不抛出异常。<br><code>C++</code>中的<code>STL</code>基本都遵循<code>RAII</code>规范，例如<code>vector</code>, <code>string</code>, <code>lock_guard</code>, <code>unique_lock</code>, <code>shared_ptr</code>, <code>unique_ptr</code>等。</p><h2 id="ScopeExit"><a href="#ScopeExit" class="headerlink" title="ScopeExit"></a><code>ScopeExit</code></h2><p><code>ScopeExit</code>可以在绑定多行代码，在程序离开<code>ScopeExit</code>所在的作用域时，会执行<code>ScopeExit</code>绑定的代码。一般用于绑定资源的清理代码。<br>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">char</span> *test = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];​<br>    <span class="hljs-keyword">if</span> (a) &#123;​<br>        <span class="hljs-keyword">delete</span>[] test; <span class="hljs-comment">// count 1​</span><br>        <span class="hljs-keyword">return</span>;​<br>    &#125;​<br>    xxx;​<br>    <span class="hljs-keyword">if</span> (b) &#123;​<br>        <span class="hljs-keyword">delete</span>[] test; <span class="hljs-comment">// count 2​</span><br>        <span class="hljs-keyword">return</span>;​<br>    &#125;​<br>    ... <span class="hljs-keyword">delete</span>[] test; <span class="hljs-comment">// count 3​</span><br>&#125;<br></code></pre></td></tr></table></figure><p>没有<code>ScopeExit</code>时，我们需要多次手动释放资源，但有了<code>ScopeExit</code>后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">char</span> *test = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];​<br>    <span class="hljs-function">std::ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;test.txt&quot;</span>)</span></span>;​<br>    ScopeExit &#123;​<br>        <span class="hljs-keyword">delete</span>[] test; <span class="hljs-comment">// 在test函数生命周期结束后自动执行delete[]操作​</span><br>        ofs.<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 在生命周期结束后自动关闭文件，这里只是举个不恰当例子，ofstream自动生命周期结束后就会关闭​</span><br>    &#125;;​<br>    <span class="hljs-keyword">if</span> (a) &#123;​<br>        <span class="hljs-keyword">return</span>;​<br>    &#125;​<br>    xxx;​<br>    <span class="hljs-keyword">if</span> (b) &#123;​<br>        <span class="hljs-keyword">return</span>;​<br>    &#125;​<br>    ...​<br>&#125;​<br></code></pre></td></tr></table></figure><p>我们只需要用<code>ScopeExit</code>绑定一次资源的清理代码即可。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中运算符的重载</title>
    <link href="/2025/06/13/cpp-operator-overload/"/>
    <url>/2025/06/13/cpp-operator-overload/</url>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>C++中运算符可以通过下面的方式重载，从而为自定义类型定义运算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">返回类型 <span class="hljs-keyword">operator</span>运算符(参数列表);<br></code></pre></td></tr></table></figure><p>可以重载的运算符包括</p><ul><li>算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）</li><li>关系运算符（<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>）</li><li>赋值运算符（<code>=</code>）</li><li>插入流和提取流运算符（<code>&lt;&lt;</code>、<code>&gt;&gt;</code>）</li></ul><p>等。</p><h2 id="运算符重载实例"><a href="#运算符重载实例" class="headerlink" title="运算符重载实例"></a>运算符重载实例</h2><h3 id="1-算术运算符（-、-、-、-）"><a href="#1-算术运算符（-、-、-、-）" class="headerlink" title="1. 算术运算符（+、-、*、/）"></a>1. 算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 这里仅是为了举例，实际项目中不建议使用默认参数</span><br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br><br>    <span class="hljs-comment">// 成员函数形式重载+</span><br>    Complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(real + other.real, imag + other.imag);<br>    &#125;<br><br>    <span class="hljs-comment">// 成员函数形式重载-</span><br>    Complex <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Complex&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(real - other.real, imag - other.imag);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; real &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span></span>;<br>    <span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span></span>;<br><br>    Complex c3 = c1 + c2; <span class="hljs-comment">// 使用重载的+运算符</span><br>    c<span class="hljs-number">3.</span><span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：4 + 6i</span><br><br>    Complex c4 = c1 - c2; <span class="hljs-comment">// 使用重载的-运算符</span><br>    c<span class="hljs-number">4.</span><span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：2 + 2i</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>算符运算符重载的返回值是同类型的对象</p><ul><li>因为算术运算符本身就不修改操作符，返回同类型的对象符合语义</li><li>算术运算符本身就要在操作符函数内产生新的对象，这个对象的作用域局限在函数内部，如果返回引用的话，这个引用所绑定的对象在函数结束后会被释放，返回引用会出现段错误<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">Complex&amp; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other) <span class="hljs-type">const</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Complex</span>(real + other.real, imag + other.imag);<span class="hljs-comment">//error,cannot bind non-const lvalue reference of type ‘Complex&amp;’ to an rvalue of type ‘Complex’</span><br>&#125;<br></code></pre></td></tr></table></figure>如果返回引用，就不能向上面这样写了，因为这样写的返回值是一个<strong>不具名的右值</strong>，不能绑定到左值引用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">int</span> r, <span class="hljs-type">int</span> i):<span class="hljs-built_in">real</span>(r),<span class="hljs-built_in">imag</span>(i) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Complex(int, int) constructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    Complex&amp; <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Complex&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-function">Complex <span class="hljs-title">result</span><span class="hljs-params">(real + other.real, imag + other.imag)</span></span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; real &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">Complex</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Complex destructor called&quot;</span> &lt;&lt; std::endl;<br>    &#125;   <br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">num1</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-function">Complex <span class="hljs-title">num2</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    Complex result = num1 + num2;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;num1 = :&quot;</span>;<br>    num<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;num2 = :&quot;</span>;<br>    num<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;num1 + num2 = :&quot;</span>;<br>    result.<span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>上代码的输出是<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">Complex(int, int) constructor called<br>Complex(int, int) constructor called<br>Complex(int, int) constructor called<br>Complex destructor called<br></code></pre></td></tr></table></figure>并且在运行到<code>Complex result = num1 + num2;</code>出现了段错误<code>Segmentation fault</code>,说明<code>result</code>在函数结束时就已经析构，因此<code>Complex&amp;</code>找不到要绑定的对象。</li></ul><h3 id="2-关系运算符（-、-、）"><a href="#2-关系运算符（-、-、）" class="headerlink" title="2. 关系运算符（==、!=、&lt;、&gt;）"></a>2. 关系运算符（<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 同上，这里仅是为了举例，实际项目中不建议使用默认参数</span><br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br><br>    <span class="hljs-comment">// 成员函数形式重载==</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Complex&amp; other) &#123;<br>        <span class="hljs-built_in">return</span> (real == other.real) &amp;&amp; (imag == other.imag);<br>    &#125;<br><br>    <span class="hljs-comment">// 成员函数形式重载!=</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Complex&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == other);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; real &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span></span>;<br>    <span class="hljs-function">Complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>)</span></span>;<br>    <span class="hljs-function">Complex <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;c1 and c2 are equal.&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;c1 and c2 are not equal.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (c1 != c3) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;c1 and c3 are not equal.&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;c1 and c3 are equal.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-赋值运算符（-）"><a href="#3-赋值运算符（-）" class="headerlink" title="3. 赋值运算符（=）"></a>3. 赋值运算符（<code>=</code>）</h3><p>需要注意的是</p><ul><li>返回值应该是对象的引用<ul><li>允许进行连续赋值 <code>obj3 = obj2 = obj1</code></li><li>防止返回对象时调用拷贝构造函数和析构函数，造成不必要的开销</li></ul></li><li>需要注意自赋值问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* str;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s = <span class="hljs-string">&quot;&quot;</span>) &#123;<br>        str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(s) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(str, s);<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyString</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] str;<br>    &#125;<br><br>    <span class="hljs-comment">// 赋值运算符重载</span><br>    MyString&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyString&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) &#123;<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 处理自我赋值</span><br>        &#125;<br>        <span class="hljs-keyword">delete</span>[] str; <span class="hljs-comment">// 释放原有内存</span><br>        str = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(other.str) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(str, other.str);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; str &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyString <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    <span class="hljs-function">MyString <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;World&quot;</span>)</span></span>;<br><br>    s<span class="hljs-number">1.</span><span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：Hello</span><br>    s<span class="hljs-number">2.</span><span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：World</span><br><br>    s2 = s1; <span class="hljs-comment">// 使用重载的=运算符</span><br>    s<span class="hljs-number">2.</span><span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出：Hello</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-插入流和提取流运算符（）"><a href="#4-插入流和提取流运算符（）" class="headerlink" title="4. 插入流和提取流运算符（&lt;&lt;、&gt;&gt;）"></a>4. 插入流和提取流运算符（<code>&lt;&lt;</code>、<code>&gt;&gt;</code>）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> real;<br>    <span class="hljs-type">double</span> imag;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Complex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;<br><br>    <span class="hljs-comment">// 友元函数形式重载&lt;&lt;</span><br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Complex&amp; c);<br>&#125;;<br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="hljs-type">const</span> Complex&amp; c) &#123;<br>    os &lt;&lt; c.real &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span>;<br>    <span class="hljs-keyword">return</span> os;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Complex c;<br>    cout &lt;&lt; c &lt;&lt; endl; <span class="hljs-comment">// 使用重载的&lt;&lt;运算符</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>以下的运算符不能重载<ul><li>成员访问运算符 <code>.</code></li><li>成员指针访问 <code>.*</code></li><li>作用域解析运算符 <code>::</code></li><li>条件运算符 <code>?:</code></li><li><code>sizeof</code>运算符</li></ul></li><li>运算符重载不能改变运算符的优先级和结合性</li><li>基本数据类型的运算符不能重载，如果运算符有2个及以上操作数，则至少一个操作数是自定义类型</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的static关键字</title>
    <link href="/2025/06/13/cpp-static/"/>
    <url>/2025/06/13/cpp-static/</url>
    
    <content type="html"><![CDATA[<h2 id="static的引入"><a href="#static的引入" class="headerlink" title="static的引入"></a><code>static</code>的引入</h2><p><code>static</code>是C++中的修饰符，可以修饰变量和函数，用来控制变量的存储方式和可见性。</p><p>一般情况下，函数内部的变量，在程序运行到它的定义时，会在栈内为其分配内存，在函数执行结束后释放。如果我们想要某些变量（例如记录函数调用次数的变量）的生命周期不局限于函数执行期间，在执行结束后不释放而是继续保留，并且在同时确保将其作用域限制在函数内部，那么一般的变量和全局变量（虽然生命周期不局限于函数执行期间，但是其作用域也不局限于函数内部）都无法满足我们的需求，因此引入了<code>static</code>关键字来解决这个问题。</p><h2 id="static的使用"><a href="#static的使用" class="headerlink" title="static的使用"></a><code>static</code>的使用</h2><h3 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h3><p>如前文所述，函数内的局部变量可以用<code>static</code>修饰，将其声明为静态局部变量，这样它的生命周期贯穿整个函数运行期间的同时作用域也能限制在函数内部。</p><p>C++11 标准规定，<strong>静态局部变量的初始化只会发生一次</strong>，因此在多线程环境下，初始化过程是线程安全的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 静态局部变量​</span><br>    count++;​<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 输出: Count: 1​</span><br>    <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 输出: Count: 2​</span><br>    <span class="hljs-built_in">func</span>();  <span class="hljs-comment">// 输出: Count: 3​</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h3><p>在全局作用域中，<code>static</code> 关键字可以用来限制变量的<strong>链接性</strong>、<strong>可见性</strong>。​<br>​静态全局变量只能在定义它的文件中访问，<strong>其他文件无法访问该变量</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file1.cpp​</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> globalVar = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 静态全局变量​</span><br>​<br><span class="hljs-comment">// file2.cpp​</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> globalVar;  <span class="hljs-comment">// 错误: globalVar 在 file2.cpp 中不可见</span><br></code></pre></td></tr></table></figure><h3 id="类的静态成员变量"><a href="#类的静态成员变量" class="headerlink" title="类的静态成员变量"></a>类的静态成员变量</h3><ul><li>类的静态成员变量属于类本身，而不是某个对象</li><li>静态成员变量在所有对象间共享</li><li>静态成员变量一定要在类外初始化<ul><li>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，则该类再一次创建对象时静态成员将再一次被“初始化”（变成初始值），会修改其他对象对该静态变量操作的意图，可能发生意外。</li><li>C++11 起，允许对常量静态成员变量在类内部进行初始化</li></ul></li><li>静态成员变量可以直接通过类名访问，因为它本身就位于类空间而不是普通成员空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;  <span class="hljs-comment">// 静态成员变量声明​</span><br>&#125;;​<br>​<br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 静态成员变量定义​,注意这里需要有类型标识符</span><br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    MyClass obj1;​<br>    MyClass obj2;​<br>​<br>    obj<span class="hljs-number">1.</span>staticVar = <span class="hljs-number">10</span>;​<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2.staticVar: &quot;</span> &lt;&lt; obj<span class="hljs-number">2.</span>staticVar &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 10​</span><br>​<br>    MyClass::staticVar = <span class="hljs-number">20</span>;​<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1.staticVar: &quot;</span> &lt;&lt; obj<span class="hljs-number">1.</span>staticVar &lt;&lt; std::endl;  <span class="hljs-comment">// 输出: 20​</span><br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><h3 id="类的静态成员函数"><a href="#类的静态成员函数" class="headerlink" title="类的静态成员函数"></a>类的静态成员函数</h3><ul><li>静态成员函数属于类本身，而不是某个对象。</li><li>由于<code>this</code>指针指向的是某个具体的对象，因此静态成员函数没有<code>this</code>指针</li><li>静态成员函数只能访问静态成员变量和静态成员函数，因为它没有<code>this</code>指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticFunc</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 静态成员函数​</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Static function called.&quot;</span> &lt;&lt; std::endl;​<br>    &#125;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    MyClass::<span class="hljs-built_in">staticFunc</span>();  <span class="hljs-comment">// 通过类名调用静态成员函数​</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修饰普通函数"><a href="#修饰普通函数" class="headerlink" title="修饰普通函数"></a>修饰普通函数</h3><p>当<code>static</code>用来修饰普通函数时，其作用是限制函数的链接性，当一个普通函数被 <code>static</code> 修饰时，它的符号（函数名）不会被导出到全局符号表中，因此其他文件无法通过 <code>extern</code> 声明来引用该函数。这种特性可以用于隐藏函数的实现细节，避免命名冲突，或者限制函数的作用域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file1.cpp​</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">hiddenFunction</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// static 修饰的普通函数​</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;This function is hidden from other files.&quot;</span> &lt;&lt; std::endl;​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publicFunction</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-built_in">hiddenFunction</span>();  <span class="hljs-comment">// 可以在本文件中调用​</span><br>&#125;​<br>​<br><span class="hljs-comment">// file2.cpp​</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">hiddenFunction</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 错误: hiddenFunction 在 file2.cpp 中不可见​</span><br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">anotherFunction</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-built_in">hiddenFunction</span>();  <span class="hljs-comment">// 错误: hiddenFunction 在 file2.cpp 中不可见​</span><br>&#125;​<br></code></pre></td></tr></table></figure><h2 id="匿名空间"><a href="#匿名空间" class="headerlink" title="匿名空间"></a>匿名空间</h2><p>要想实现将符号的作用域限制在本文件中，除了用<code>static</code>修饰外，还可以使用匿名空间来实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// file1.cpp​</span><br><span class="hljs-keyword">namespace</span> &#123;  <span class="hljs-comment">// 匿名命名空间​</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hiddenFunction</span><span class="hljs-params">()</span> </span>&#123;​<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;This function is hidden from other files.&quot;</span> &lt;&lt; std::endl;​<br>    &#125;​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publicFunction</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-built_in">hiddenFunction</span>();  <span class="hljs-comment">// 可以在本文件中调用​</span><br>&#125;​<br>​<br><span class="hljs-comment">// file2.cpp​</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">hiddenFunction</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 错误: hiddenFunction 在 file2.cpp 中不可见​</span><br></code></pre></td></tr></table></figure><p>与<code>static</code>的区别在于</p><ul><li><code>static</code> 是 C 语言风格的用法，而匿名命名空间是 C++ 特有的特性。​</li><li>匿名命名空间可以隐藏类、变量、函数等多种符号，而 <code>static</code> 只能用于函数和变量。​</li><li>匿名命名空间更符合 C++ 的现代编程风格，推荐优先使用。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/33debug/p/7223869.html">C&#x2F;C++中static的用法全局变量与局部变量</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++类型转换</title>
    <link href="/2025/06/13/cpp-type-conversion/"/>
    <url>/2025/06/13/cpp-type-conversion/</url>
    
    <content type="html"><![CDATA[<h3 id="C风格强制类型转换"><a href="#C风格强制类型转换" class="headerlink" title="C风格强制类型转换"></a>C风格强制类型转换</h3><p>C语言中强制类型转换的方式为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">(type_name) expression<br></code></pre></td></tr></table></figure><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> sum = <span class="hljs-number">17</span>, count = <span class="hljs-number">5</span>;<br>   <span class="hljs-type">double</span> mean;<br> <br>   mean = (<span class="hljs-type">double</span>) sum / count;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Value of mean : %f\n&quot;</span>, mean );<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>C风格的强制类型转换虽然方式简单，可以在任意类型之间转换，但这同时也导致了C风格强制类型转换极其不安全，需要严格的代码审查。</p><h3 id="C-风格强制类型转换"><a href="#C-风格强制类型转换" class="headerlink" title="C++风格强制类型转换"></a>C++风格强制类型转换</h3><p>因此C++在完全兼容C的基础上，引入了新的强制类型转换。</p><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h4><p>用于基本数据类型之间的转换，例如</p><ul><li><code>float</code>转<code>int</code>，<code>int</code>转<code>char</code>等</li><li>在有类型指针和<code>void*</code>之间转换使用,但<strong>不能</strong>使用<code>static_cast</code>在<strong>有类型指针之间</strong>进行类型转换。</li><li><strong>子类对象指针转换成父类对象指针</strong>也可以使用<code>static_cast</code>。​</li></ul><p>非多态类型转换一般都使用<code>static_cast</code>，而且最好把所有的隐式类型转换都用<code>static_cast</code>进行显式替换，但不能使用<code>static_cast</code>在有类型指针之间进行类型转换。</p><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a><code>dynamic_cast</code></h4><p>一般用于将<strong>父类的指针转换为子类的指针</strong>，此场景下父类<strong>必须要有虚函数</strong>，因为<code>dynamic_cast</code>是运行时检查，检查需要有运行时信息<code>RTTI</code>，而<code>RTTI</code>存储在虚函数表中</p><p>如果父类没有虚函数，或者转换的双方不是父子关系，<code>dynamic_cast</code>会返回<code>nullptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Base</span> &#123;​<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Base Func \n&quot;</span>; &#125;​<br>&#125;;​<br>​<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Derive</span> : <span class="hljs-keyword">public</span> Base &#123;​<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot;Derive Func \n&quot;</span>; &#125;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    Derive d;​<br>    d.<span class="hljs-built_in">Func</span>();​<br>    Base *b = <span class="hljs-built_in">dynamic_cast</span>&lt;Base *&gt;(&amp;d);​<br>    b-&gt;<span class="hljs-built_in">Func</span>();​<br>    Derive *dd = <span class="hljs-built_in">dynamic_cast</span>&lt;Derive *&gt;(b);​<br>    dd-&gt;<span class="hljs-built_in">Func</span>();​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h4><p>一般用于<strong>常量指针与非常量指针之间</strong>的转换，只有<code>const_cast</code>才可以对常量进行操作，一般用它来<strong>去除常量性</strong>(也能够去除<code>volatile</code>)，但去除常量性是危险操作，还是要谨慎使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">int</span> data = <span class="hljs-number">10</span>;​<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> *cpi = &amp;data;​<br>    <span class="hljs-type">int</span> *pi = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> *&gt;(cpi);​<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> *cpii = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span> *&gt;(pi);​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a><code>reinterpret_cast</code></h4><p>类似C语言中的强制类型转换，基本上什么都可以转,有安全风险。如果其他的强制转换无法解决问题，再考虑<code>reinterpret_cast</code></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++列表初始化</title>
    <link href="/2025/06/13/cpp-list-initialization/"/>
    <url>/2025/06/13/cpp-list-initialization/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>列表初始化是C++11引入的新特性，通过<code>&#123;&#125;</code>来初始化对象，其优点在于</p><ol><li>统一的初始化语法，内置类型、数组、类和标准库容器都可以列表初始化</li><li>类型安全，可以防止窄化转换。窄化转换是指将较大的类型转换为较小的类型，这可能会导致数据的丢失。例如从<code>double</code>到<code>int</code>就是<strong>窄化</strong>的类型转换，如果用<code>double</code>类型列表初始化<code>int</code>类型的变量，会发生编译错误，而传统的<code>=</code>初始化则不会</li></ol><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><h3 id="1-初始化内置类型"><a href="#1-初始化内置类型" class="headerlink" title="1. 初始化内置类型"></a>1. 初始化内置类型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = &#123;<span class="hljs-number">10</span>&#125;;   <span class="hljs-comment">// 使用列表初始化</span><br><span class="hljs-type">int</span> b&#123;<span class="hljs-number">20</span>&#125;;      <span class="hljs-comment">// 另一种写法</span><br></code></pre></td></tr></table></figure><h3 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2. 初始化数组"></a>2. 初始化数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// 数组初始化</span><br><span class="hljs-type">int</span> arr2[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;  <span class="hljs-comment">// 自动推导数组大小</span><br></code></pre></td></tr></table></figure><h3 id="3-初始化类对象"><a href="#3-初始化类对象" class="headerlink" title="3. 初始化类对象"></a>3. 初始化类对象</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    std::string name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">int</span> a) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) &#123;&#125;<br>&#125;;<br>Person p1&#123;<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-number">30</span>&#125;;  <span class="hljs-comment">// 使用列表初始化类的成员变量，需要与成员变量的声明顺序一致</span><br></code></pre></td></tr></table></figure><h3 id="4-初始化标准库容器"><a href="#4-初始化标准库容器" class="headerlink" title="4. 初始化标准库容器"></a>4. 初始化标准库容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;; <span class="hljs-comment">// 初始化 vector</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec2&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;;      <span class="hljs-comment">// 另一种写法</span><br></code></pre></td></tr></table></figure><h3 id="5-初始化结构体"><a href="#5-初始化结构体" class="headerlink" title="5. 初始化结构体"></a>5. 初始化结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><br>Point p1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;;  <span class="hljs-comment">// 使用列表初始化</span><br>Point p2&#123;<span class="hljs-number">30</span>, <span class="hljs-number">40</span>&#125;;     <span class="hljs-comment">// 另一种写法</span><br></code></pre></td></tr></table></figure><h2 id="列表初始化与重载"><a href="#列表初始化与重载" class="headerlink" title="列表初始化与重载"></a>列表初始化与重载</h2><p>函数可以使用列表初始化作为输入来重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>;  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> std::initializer_list&lt;<span class="hljs-type">int</span>&gt;&amp; list)</span></span>;  <br>  <br><span class="hljs-built_in">foo</span>(&#123;<span class="hljs-number">10</span>&#125;); <span class="hljs-comment">// 调用接受 initializer_list 的 foo 版本  </span><br><span class="hljs-built_in">foo</span>(<span class="hljs-number">10</span>);   <span class="hljs-comment">// 调用接受 int 的 foo 版本</span><br></code></pre></td></tr></table></figure><p>类的构造函数也可以通过列表初始化来重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> std::initializer_list&lt;<span class="hljs-type">int</span>&gt;&amp; values) &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : values) &#123;  <br>            <span class="hljs-comment">// 使用values初始化对象的状态...  </span><br>        &#125;  <br>    &#125;  <br>    <span class="hljs-comment">// ... 其他成员函数 ...  </span><br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    MyClass obj&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;; <span class="hljs-comment">// 使用列表初始化创建对象  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的类型推断</title>
    <link href="/2025/06/12/cpp-auto-decltype/"/>
    <url>/2025/06/12/cpp-auto-decltype/</url>
    
    <content type="html"><![CDATA[<p>C++11中引入了<code>auto</code>和<code>decltype</code>，他们可以在编译期推导出出变量或表达式的类型，大幅简化了代码。</p><h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a><code>auto</code></h2><p><code>auto</code>关键字允许编译器在编译期间自动推导出变量的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> a = <span class="hljs-number">10</span>;       <span class="hljs-comment">// a是int型​</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;​<br><span class="hljs-keyword">auto</span> b = i;        <span class="hljs-comment">// b是int型​</span><br><span class="hljs-keyword">auto</span> d = <span class="hljs-number">2.0</span>;      <span class="hljs-comment">// d是double型</span><br></code></pre></td></tr></table></figure><h3 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h3><ul><li><code>auto</code>变量必须在声明时立即初始化</li><li>当一行中声明了多个<code>auto</code>变量时，他们必须能够从一个共同的初始化表达式中推导出相同类型。</li><li>在推导类型时，<code>auto</code>会<strong>忽略等号右边的<code>const</code>、<code>volatile</code>（cv）属性和引用类型</strong>，除非显式地声明为引用或指针。</li><li><code>auto</code>不能用作函数的参数</li><li><code>auto</code>无法作为模板</li><li><code>auto</code>在类中不能用作非静态的成员变量</li><li><code>auto</code>不能用于定义数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> value)</span> </span>&#123;&#125; <span class="hljs-comment">// error，auto不能用作函数参数​</span><br>​<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;​<br>    <span class="hljs-keyword">auto</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// error，在类中auto不能用作非静态成员变量​</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> b = <span class="hljs-number">1</span>; <span class="hljs-comment">// error，这里与auto无关，正常static int b = 1也不可以​</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> c = <span class="hljs-number">1</span>; <span class="hljs-comment">// ok​</span><br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;​<br>    <span class="hljs-keyword">auto</span> b = a; <span class="hljs-comment">// ok​</span><br>    <span class="hljs-keyword">auto</span> c[<span class="hljs-number">10</span>] = a; <span class="hljs-comment">// error，auto不能定义数组，可以定义指针​</span><br><br>    vector&lt;<span class="hljs-type">int</span>&gt; d;​ <br>    vector&lt;<span class="hljs-keyword">auto</span>&gt; f = d; <span class="hljs-comment">// error，auto无法推导出模板参数​</span><br>    <br>    <span class="hljs-keyword">auto</span> e; <span class="hljs-comment">// error，使用auto必须马上初始化</span><br>    <br>    <span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;​<br>    <span class="hljs-keyword">auto</span> ai = i, &amp;bi = i, *ci = &amp;i; <span class="hljs-comment">// a是int，b是int的引用，c是int的指针​</span><br>    <br>    floats j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> di = i, aj = j; <span class="hljs-comment">//error, </span><br><br><br>    <span class="hljs-keyword">auto</span> f = <span class="hljs-number">0</span>, g = <span class="hljs-number">1.0</span>; <span class="hljs-comment">// error，0和1.0类型不同，编译器懵了，无法推导</span><br>    <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;​<br>    <span class="hljs-keyword">auto</span> y = x; <span class="hljs-comment">// y是int，忽略了const属性​</span><br>    <span class="hljs-keyword">auto</span>&amp; z = x; <span class="hljs-comment">// z是const int&amp;，保留了引用和const属性</span><br>&#125;​<br></code></pre></td></tr></table></figure><h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a><code>decltype</code></h2><p>与<code>auto</code>不同，<code>decltype</code>用于推导表达式的类型而非变量的类型。其在编译期间发挥分析表达式的类型，但是<strong>表达式本身不会进行运算</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;​<br><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">func</span>()) i; <span class="hljs-comment">// i为int类型，与func()返回值类型相同​</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;​<br><span class="hljs-keyword">decltype</span>(x) y; <span class="hljs-comment">// y是int类型，与x类型相同​</span><br><span class="hljs-keyword">decltype</span>(x + y) z; <span class="hljs-comment">// z是int类型，与表达式x + y的类型相同</span><br></code></pre></td></tr></table></figure><h3 id="推导规则-1"><a href="#推导规则-1" class="headerlink" title="推导规则"></a>推导规则</h3><ul><li>如果<code>exp</code>是一个没有圆括号的标识符表达式（id-expression），例如变量名、函数名和枚举常量名，那么<code>decltype(exp)</code>的类型与<code>exp</code>的类型相同。例如上面代码中的<code>decltype(x)</code>推导出的类型是<code>int</code>，这是因为<code>decltype(x)</code>和<code>decltype((x))</code>是不同的类型<ul><li>当<code>x</code>是变量名时，<code>decltype</code> 直接获取该变量的声明类型，<strong>结果包含原始的 <code>const</code> 限定符、引用类型等修饰符。</strong></li><li>当表达式是 <code>(x)</code>（带括号）时，C++ 将其视为普通左值表达式，<code>decltype</code> 会推导出表达式结果类型和值类别，对命名变量使用括号会添加引用。</li></ul></li><li>如果<code>exp</code>是函数调用，则<code>decltype(exp)</code>的类型与函数返回值的类型相同。</li><li>如果<code>exp</code>是左值，则<code>decltype(exp)</code>是<code>exp</code>类型的<strong>左值引用</strong><ul><li>注意和第一种情况的辨析</li></ul></li><li>与<code>auto</code>不同，<code>decltype</code>会<strong>保留<code>exp</code>的cv属性和引用类型</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>;​<br><span class="hljs-keyword">decltype</span>(a + b) c = <span class="hljs-number">0</span>; <span class="hljs-comment">// c是int，因为(a+b)返回一个右值​</span><br><span class="hljs-keyword">decltype</span>(a += b) d = a; <span class="hljs-comment">// d是int&amp;，因为(a+=b)返回一个左值​</span><br>d = <span class="hljs-number">20</span>; <span class="hljs-comment">// 修改d实际上修改了a的值​</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ref = a;​<br><span class="hljs-keyword">decltype</span>(ref) e = <span class="hljs-number">20</span>; <span class="hljs-comment">// e是const int&amp;，保留了const引用属性</span><br></code></pre></td></tr></table></figure><p><code>decltype</code>常和<code>auto</code>一起配合使用。比如处理复杂的类型和模板编程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;​<br><span class="hljs-keyword">auto</span> it = vec.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 使用auto简化迭代器类型声明​</span><br><span class="hljs-keyword">decltype</span>(*it) value = *it; <span class="hljs-comment">// 使用decltype推导迭代器指向的元素的类型</span><br></code></pre></td></tr></table></figure><p>以及推导函数返回值的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;​<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">add</span><span class="hljs-params">(T t, U u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t + u)</span> </span>&#123;​<br>    <span class="hljs-keyword">return</span> t + u;​<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;​<br><span class="hljs-keyword">decltype</span>(t + u) <span class="hljs-built_in">add</span>(T t, U u) &#123; <span class="hljs-comment">// t和u尚未定义​</span><br>    <span class="hljs-keyword">return</span> t + u;​<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码在C++11上是编译不过的，因为<strong>函数的返回类型是在参数名可见之前就解析</strong>的，也就是说编译器会先解析<code>decltype(t + u)</code>，而此时<code>t</code>和<code>u</code>尚未定义，这就导致了编译器无法编译<code>decltype(t + u)</code>，出现错误。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++构造函数</title>
    <link href="/2025/06/12/cpp-constructor/"/>
    <url>/2025/06/12/cpp-constructor/</url>
    
    <content type="html"><![CDATA[<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul><li><strong>浅拷贝</strong> <ul><li>就是对变量的简单按位复制内存</li><li>在C++中，默认的拷贝构造函数制作按位复制，也就是浅拷贝</li></ul></li><li><strong>深拷贝</strong> <ul><li>深拷贝除了将所有的成员变量拷贝给新对象外，对于指针等指向外部资源的成员变量，还会为新对象分配一块新的内存，将指针指向的内容也拷贝一份，这样原有对象和新对象的内存都是互相独立的，避免两个对象互相影响和<code>double free</code>的错误。</li><li>在C++中，深拷贝必须由程序员显式地实现</li></ul></li></ul><h3 id="拷贝构造函数和赋值构造函数"><a href="#拷贝构造函数和赋值构造函数" class="headerlink" title="拷贝构造函数和赋值构造函数"></a>拷贝构造函数和赋值构造函数</h3><ul><li>拷贝构造函数<ul><li>是对构造函数的重载，函数原型为 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">myClass</span>(<span class="hljs-type">const</span> myClass &amp; obj)&#123;&#125;<br></code></pre></td></tr></table></figure>注意输入的参数应该是引用，如果不是值传递的话，在值传递时就会触发拷贝构造函数，导致无限递归，造成崩溃。</li><li>会在下面的情况被调用<ul><li>用类的一个对象去初始化另一个对象时(<code>myClass obj2(obj1)</code>和<code>myClass obj3 = obj1</code>两种写法都是)</li><li>当函数的形参是类的对象时（也就是值传递），引用传递不会调用拷贝构造函数</li><li>当函数返回值是类的对象时</li></ul></li></ul></li><li>赋值构造函数<ul><li>是赋值操作符的重载，函数原型为 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">myClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> myClass &amp; obj) &#123;<br>   ...<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>会在用一个已有对象来给另一个已经创建好的对象赋值时被调用</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;构造函数 \n&quot;</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;析构函数 \n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-built_in">memcpy</span>(data, a.data, <span class="hljs-number">100</span>);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数 \n&quot;</span>;<br>    &#125;<br><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;a) &#123;<br>            <span class="hljs-keyword">if</span> (!data) &#123;<br>                data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>            &#125;<br>            <span class="hljs-built_in">memcpy</span>(data, a.data, <span class="hljs-number">100</span>);<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;赋值构造函数 \n&quot;</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">copyTest</span><span class="hljs-params">(A a)</span> </span>&#123;<span class="hljs-comment">// 这里会调用拷贝构造函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;in copyTest \n&quot;</span>;<br>    <span class="hljs-keyword">return</span> a; <span class="hljs-comment">// 这里也会调用拷贝构造函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a; <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function">A <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>; <span class="hljs-comment">// 拷贝构造函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== \n&quot;</span>;<br>    A c = b; <span class="hljs-comment">// 拷贝构造函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== \n&quot;</span>;<br>    <span class="hljs-built_in">copyTest</span>(c); <span class="hljs-comment">// 拷贝构造函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== \n&quot;</span>;<br>    c = a; <span class="hljs-comment">// 赋值构造函数</span><br>&#125;<br><span class="hljs-comment">/* 完整的输出为</span><br><span class="hljs-comment">构造函数 </span><br><span class="hljs-comment">拷贝构造函数 </span><br><span class="hljs-comment">=== </span><br><span class="hljs-comment">拷贝构造函数 </span><br><span class="hljs-comment">=== </span><br><span class="hljs-comment">拷贝构造函数 </span><br><span class="hljs-comment">in copyTest </span><br><span class="hljs-comment">拷贝构造函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">=== </span><br><span class="hljs-comment">赋值构造函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="移动构造函数和移动赋值函数"><a href="#移动构造函数和移动赋值函数" class="headerlink" title="移动构造函数和移动赋值函数"></a>移动构造函数和移动赋值函数</h3><p>与拷贝构造函数和赋值构造函数的区别在于输入的参数为右值引用，且移动构造和移动赋值函数会<strong>直接将资源的所有权转移到当前对象</strong>，省去拷贝的步骤，能够大幅提升效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;构造函数 \n&quot;</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;析构函数 \n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">A</span>(A&amp;&amp; a) &#123;<br>        data = a.data;<span class="hljs-comment">// 直接将资源的所有权转移给当前对象</span><br>        a.data = <span class="hljs-literal">nullptr</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;移动构造函数 \n&quot;</span>;<br>    &#125;<br><br>    A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; a) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;a) &#123;<br>            data = a.data; <span class="hljs-comment">// 直接将资源的所有权转移给当前对象</span><br>            a.data = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;移动赋值函数 \n&quot;</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>     A a; <span class="hljs-comment">// 构造函数</span><br>     A d; <span class="hljs-comment">// 构造函数</span><br>     <span class="hljs-function">A <span class="hljs-title">b</span><span class="hljs-params">(std::move(a))</span></span>; <span class="hljs-comment">// 移动构造函数</span><br>     std::cout &lt;&lt; <span class="hljs-string">&quot;=== \n&quot;</span>;<br>     A c = std::<span class="hljs-built_in">move</span>(b); <span class="hljs-comment">// 移动构造函数</span><br>     std::cout &lt;&lt; <span class="hljs-string">&quot;--- \n&quot;</span>;<br>     c = std::<span class="hljs-built_in">move</span>(d); <span class="hljs-comment">// 移动赋值函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="std-move的理解"><a href="#std-move的理解" class="headerlink" title="std::move的理解"></a><code>std::move</code>的理解</h4><ul><li><code>std::move</code>的作用是将参数转换为右值引用，以便利用移动构造函数或移动赋值运算符。</li><li><strong>移动语义</strong>的目的是避免不必要的拷贝，特别是在处理大型对象或资源密集型对象时。</li><li>移动后对象的状态应为有效但不确定（通常是安全但不可预测的），即移动后的对象处于“可析构”但“不可用”的状态。</li><li><code>std::move</code>仅仅是一个类型转换，实际的移动操作由移动构造函数或移动赋值运算符完成。</li></ul><h3 id="delete-explicit和default"><a href="#delete-explicit和default" class="headerlink" title="delete,explicit和default"></a><code>delete</code>,<code>explicit</code>和<code>default</code></h3><ul><li><code>delete</code>是C++11引入的新特性，在成员函数后面使用<code>=delete</code>修饰，表示禁用该函数。智能指针<code>unique_ptr</code>就是通过禁用拷贝构造函数来实现的。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure></li><li><code>explicit</code>则在函数前面修饰，用于禁止隐式类型转换<ul><li>在 C++ 中，任何只有一个参数（或者除了第一个参数外，其它参数都有默认值）的构造函数，默认就是一个<strong>转换构造函数</strong>（converting constructor），它允许编译器在需要的时候把那个参数类型 <strong>隐式</strong> 地转换成该类的对象，例如<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a) &#123; a_ = a; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    A b = <span class="hljs-number">100</span>; <span class="hljs-comment">// 会触发隐式类型转换</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>但这样的隐式有时候并不是我们所期望的，可能只是代码写错了，为了避免这种情况，可以用<code>explicit</code>修饰构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123; a_ = a; &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li>除了构造函数外，<code>explicit</code>还可以用于修饰类型转换函数（C++11）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> some_flag; &#125;<br>&#125;;<br><br>B b;<br><span class="hljs-keyword">if</span> (b) &#123;      <span class="hljs-comment">// 错误：operator bool() 是 explicit 的，不能隐式转换</span><br>&#125;<br><span class="hljs-type">bool</span> x = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">bool</span>&gt;(b);  <span class="hljs-comment">// OK：显式转换</span><br><br></code></pre></td></tr></table></figure></li></ul></li><li><code>default</code>一般用于修饰构造函数，要求编译器生成默认的构造函数。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a) &#123; a_ = a; &#125;​<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;​<br>    ​<br><span class="hljs-keyword">private</span>:​<br>    <span class="hljs-type">int</span> a_;​<br>&#125;;​<br>​<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>&#125;<br></code></pre></td></tr></table></figure>  上面的代码会由于<code>A</code>没有无参数的构造函数而导致报错，可以在<code>A</code>中添加  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure>  解决，但是默认的构造函数并不会将<code>a_</code>初始化。<br>  此外<code>default</code>也可以修饰拷贝构造函数。</li></ul><!-- ### 自赋值问题的解决C++允许一个变量有多个别名（指针和引用），因此可能会导致自赋值的出现，而这虽然合法却不安全。由于赋值构造函数一般遵循下面的范式：1. 释放本对象中的资源2. 将等号右边对象的资源拷贝一份给本对象<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  Bitmap *pb;     <br>&#125;;<br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此上面的代码，当<code>rhs == *this</code>时，<code>delete pb</code>使得<code>rhs.pb</code>成为空值，接下来<code>new</code>的数据便是空的,导致自身资源的丢失。要解决自赋值问题，最简单也是最容易想到的就是检查传入的参数是否是<code>*this</code>，但却不是<strong>异常安全</strong>的<br> –&gt;</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/myrosy/p/17377409.html">[cnblog.com] C++ 深拷贝、浅拷贝及拷贝构造函数</a></li></ul><!-- * [Effective C++ 11：赋值运算符的自赋值问题](https://harttle.land/2015/07/30/effective-cpp-11.html)  -->]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的值类型</title>
    <link href="/2025/06/11/cpp-lrval/"/>
    <url>/2025/06/11/cpp-lrval/</url>
    
    <content type="html"><![CDATA[<!-- ## 基本定义 --><p>C++中表达式的结果有两个属性：类型和值类别（value categories），类型影响值的表示范围和所占的存储空间，值类别则影响</p><ul><li>能否取地址和修改</li><li>引用的绑定规则</li><li>生命周期</li></ul><p>等特性。分为以下几类</p><h4 id="1-左值-lvalue"><a href="#1-左值-lvalue" class="headerlink" title="1. 左值 lvalue"></a>1. 左值 <code>lvalue</code></h4><p>具有存储位置的对象，可以被修改和获取，且在<strong>表达式结束后依然存在</strong>。简单地说，<strong>能够用<code>&amp;</code>取地址的就是左值</strong>。包括</p><ul><li>函数名<br>当我们将一个函数名作为值来使用时，它会自动转换成指向对应函数的指针</li><li>具名的变量 例如<code>std::cin</code>,<code>std::endl</code></li><li>返回左值引用的函数调用</li><li>前置自增&#x2F;自减运算符的表达式 例如<code>++i</code>,<code>--i</code></li><li>由赋值运算符或复合赋值运算符连接的表达式 例如<code>a=b</code>、<code>a+=b</code>、<code>a%=b</code></li><li>解引用表达式</li><li>字符串字面值 例如<code>&quot;abac&quot;</code></li></ul><h4 id="2-纯右值-prvalue"><a href="#2-纯右值-prvalue" class="headerlink" title="2. 纯右值 prvalue"></a>2. 纯右值 <code>prvalue</code></h4><p>不与对象的存储位置直接关联，无法获取地址且没有标识符（也就是不具名）的临时对象，包括</p><ul><li>除了字符串字面量以外的字面量 例如3，<code>false</code></li><li>返回非引用类型的函数调用</li><li>后置自增&#x2F;自减运算符的表达式 例如<code>i++</code>,<code>i--</code></li><li>算术表达式 <code>a+b</code>,<code>a&amp;b</code></li><li>逻辑表达 <code>a&amp;&amp;b</code>,<code>a||n</code>,<code>~a</code></li><li>比较表达式 <code>a==b</code></li><li>取址表达式 <code>&amp;a</code> 等</li></ul><h4 id="3-将亡值-xvalue"><a href="#3-将亡值-xvalue" class="headerlink" title="3. 将亡值 xvalue"></a>3. 将亡值 <code>xvalue</code></h4><p>在C++11之前的右值和C++11后的纯右值是等价的。C++11中的将亡值是随着右值引用<code>T&amp;&amp;</code>的引入而引入的。将亡值表达式就是下列表达式：</p><ul><li>返回右值引用的函数的调用表达式</li><li>转换为右值引用的转换函数的调用表达式</li></ul><p>之所以要引入右值引用和将亡值，是因为在C++中，当我们使用一个<strong>左值</strong>去初始化一个新对象或者给已有的对象赋值时，会调用<strong>拷贝构造函数</strong>或<strong>赋值运算符</strong>来拷贝资源。在C++11中，引入了<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，当用<strong>右值</strong>来来初始化或赋值的话，这两个函数来实现，从而避免拷贝，提高效率。这个右值完成为左值初始化或赋值的任务后，它的资源已经被移动给了这个左值，其本身马上就会被析构。也就说，这个右值在被定义时，它就是“将亡”的了。</p><h4 id="4-广义左值和右值"><a href="#4-广义左值和右值" class="headerlink" title="4. 广义左值和右值"></a>4. 广义左值和右值</h4><p>广义左值包含左值和将亡值，右值包含纯右值和将亡值。</p><h4 id="值类型的辨析"><a href="#值类型的辨析" class="headerlink" title="值类型的辨析"></a>值类型的辨析</h4><h5 id="1-字符串字面量是左值"><a href="#1-字符串字面量是左值" class="headerlink" title="1. 字符串字面量是左值"></a>1. 字符串字面量是左值</h5><p>字符串字面值是所有字面值中唯一的左值，而其他的字面值都是右值，这是因为早期间C++将字符串字面值实现为<code>char</code>类型的数组，为每个字符都分配了空间并允许进行操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout&lt;&lt;&amp;(<span class="hljs-string">&quot;abc&quot;</span>)&lt;&lt;endl;<br><span class="hljs-type">char</span> *p_char=<span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//注意不是char *p_char=&amp;(&quot;abc&quot;);</span><br></code></pre></td></tr></table></figure><p>例如上面的代码，字符串字面量<code>&quot;abc&quot;</code>可以直接用来取地址和给指针赋值，<code>p_char</code>的值就是字符串首字母<code>&#39;a&#39;</code>的地址</p><h5 id="2-具名的右值引用是左值，不具名的右值引用是右值"><a href="#2-具名的右值引用是左值，不具名的右值引用是右值" class="headerlink" title="2. 具名的右值引用是左值，不具名的右值引用是右值"></a>2. 具名的右值引用是左值，不具名的右值引用是右值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-comment">// 两个重载，用于区分传入的是左值还是右值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Called identify(int&amp;): lvalue\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Called identify(int&amp;&amp;): rvalue\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 1. 普通左值</span><br>    <span class="hljs-built_in">identify</span>(a);            <span class="hljs-comment">// 匹配 int&amp;  —— 输出 lvalue</span><br><br>    <span class="hljs-comment">// 2. 字面右值</span><br>    <span class="hljs-built_in">identify</span>(<span class="hljs-number">20</span>);           <span class="hljs-comment">// 匹配 int&amp;&amp; —— 输出 rvalue</span><br><br>    <span class="hljs-comment">// 3. 具名的右值引用</span><br>    <span class="hljs-type">int</span>&amp;&amp; r = <span class="hljs-number">30</span>;           <span class="hljs-comment">// r 的类型是 int&amp;&amp;，但它有名字</span><br>    <span class="hljs-built_in">identify</span>(r);            <span class="hljs-comment">// r 是一个有名字的表达式，所以被当作左值 —— 输出 lvalue</span><br><br>    <span class="hljs-comment">// 如果想把 r 当作右值，需要 std::move（或 static_cast&lt;int&amp;&amp;&gt;）</span><br>    <span class="hljs-built_in">identify</span>(std::<span class="hljs-built_in">move</span>(r)); <span class="hljs-comment">// 输出 rvalue</span><br><br>    <span class="hljs-comment">// 4. 不具名的右值引用（临时对象）</span><br>    <span class="hljs-built_in">identify</span>(<span class="hljs-type">int</span>&amp;&amp;(<span class="hljs-number">40</span>));    <span class="hljs-comment">// 直接构造的临时右值 —— 输出 rvalue</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-i和i"><a href="#3-i和i" class="headerlink" title="3. ++i和i++"></a>3. <code>++i</code>和<code>i++</code></h5><ul><li><code>++i</code>是先把<code>i</code>加1再赋值给<code>i</code>，表达式返回的值就是<code>i</code>，因此它的结果是具名的，<code>i</code>在表达式结束后依然存在，因此<code>++i</code>是左值</li><li><code>i++</code>则是先对<code>i</code>进行拷贝，将拷贝的副本返回后再对<code>i</code>加1，由于返回的结果是<code>i</code>的拷贝，因此是不具名的，是纯右值</li></ul><h4 id="左值与右值的转换"><a href="#左值与右值的转换" class="headerlink" title="左值与右值的转换"></a>左值与右值的转换</h4><p>可以使用<code>std::move</code>将左值转换成右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-comment">// 两个重载，用于区分传入的是左值还是右值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Called identify(int&amp;): lvalue\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Called identify(int&amp;&amp;): rvalue\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// 如果想把 r 当作右值，需要 std::move（或 static_cast&lt;int&amp;&amp;&gt;）</span><br>    <span class="hljs-built_in">identify</span>(std::<span class="hljs-built_in">move</span>(r)); <span class="hljs-comment">// 输出 rvalue</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h4><p>当</p><ul><li><code>T</code>是一个模板参数，且需要进行类型推导，或者</li><li>使用<code>auto &amp;&amp;</code>声明变量</li></ul><p>时，<code>T&amp;&amp;</code>或<code>auto &amp;&amp;</code>既可以绑定到左值也可以绑定到右值，称之为<strong>万能引用</strong>。</p><p>为了达成<code>T&amp;&amp;</code>或<code>auto &amp;&amp;</code>的上述功能，C++规定，当应用的引用出现时，会通过引用折叠简化为单一引用</p><ul><li><code>&amp; &amp;</code>    → <code>&amp;</code></li><li><code>&amp; &amp;&amp;</code>   → <code>&amp;</code></li><li><code>&amp;&amp; &amp;</code>   → <code>&amp;</code></li><li><code>&amp;&amp; &amp;&amp;</code>  → <code>&amp;&amp;</code></li></ul><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123; ​<br>    <span class="hljs-comment">// arg 是万能引用，可以绑定到左值或右值​</span><br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;​<br>    <span class="hljs-built_in">foo</span>(a);       <span class="hljs-comment">// T 推导为 int&amp; → arg 类型是 int&amp;（左值引用）​可以这样理解：为了让T&amp;&amp;折叠为int &amp;，所以推导T为int&amp;​</span><br>    <span class="hljs-built_in">foo</span>(<span class="hljs-number">10</span>);      <span class="hljs-comment">// T 推导为 int  → arg 类型是 int&amp;&amp;（右值引用）​</span><br>&#125;​<br></code></pre></td></tr></table></figure><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>通过<code>std::forward&lt;&gt;</code>模板，我们能够实现<strong>完美转发</strong>，即在参数传递时<strong>保留其原始的值类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br>​<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T &amp;&amp;t)</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    std::cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-string">&quot;rvalue\n&quot;</span>;​<br>&#125;​<br>​<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T &amp;t)</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    std::cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-string">&quot;lvalue\n&quot;</span>;​<br>&#125;​<br>​<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T &amp;&amp;t)</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(t));​<br>&#125;​<br>​<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper_common</span><span class="hljs-params">(T &amp;&amp;t)</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    <span class="hljs-built_in">process</span>(t);​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    <span class="hljs-comment">// 测试右值引用​</span><br>    <span class="hljs-built_in">wrapper</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// rvalue​ </span><br>    <span class="hljs-comment">// 测试左值引用​</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;​<br>    <span class="hljs-built_in">wrapper</span>(i); <span class="hljs-comment">// lvalue​ 两个process模板都可以时，编译器会选择更加specialized那个</span><br>​<br>    <span class="hljs-comment">// 测试完美转发将亡值​</span><br>    <span class="hljs-built_in">wrapper</span>(std::<span class="hljs-built_in">move</span>(i)); <span class="hljs-comment">// rvalue​</span><br>​<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;​<br>    <span class="hljs-comment">// 测试不用完美转发​</span><br>    <span class="hljs-built_in">wrapper_common</span>(std::<span class="hljs-built_in">move</span>(j)); <span class="hljs-comment">// lvalue​</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>万能引用是参数绑定的入口，负责接收任意的值类别。​</li><li>而<code>std::forward</code>是转发的出口，负责恢复原始值的类别。以上面的代码为例，<code>wrapper</code>中的<code>t</code>无论接受的是左值还是右值，在<code>wrapper</code>内部都是左值，因为它是<strong>具名</strong>的，且在栈上分配了空间。而<code>std::forward&lt;T&gt;(t)</code>则能根据<code>T</code>是<code>int</code>(<code>t</code>传入的是右值)还是<code>int &amp;</code>（<code>t</code>传入的是左值）来将<code>t</code>恢复成它原来的值类型。</li><li>之所以需要万能转发，是因为不管你传入的是右值还是左值，在函数内部，参数都是具名的，也就是说，在函数内部参数都是左值。如果这个函数需要调用其他的函数，而那个被调用的函数根据参数是左值还是右值，会有不同的行为的话，这个时候就需要用完美转发来恢复参数的值类型。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html">[cnblog] 话说C++中的左值、纯右值、将亡值</a></li><li><a href="https://theonegis.github.io/cxx/C-%E4%B8%AD%E7%9A%84%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/">C++中的万能引用和完美转发</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的异常处理</title>
    <link href="/2025/06/10/cpp-exception/"/>
    <url>/2025/06/10/cpp-exception/</url>
    
    <content type="html"><![CDATA[<h2 id="异常处理的基本操作"><a href="#异常处理的基本操作" class="headerlink" title="异常处理的基本操作"></a>异常处理的基本操作</h2><p>C++中通过下面的三个关键字来是实现异常处理</p><ul><li><code>try</code><br>用于标记可能出现异常的代码块，被<code>try</code>标记的代码块称为保护代码</li><li><code>throw</code><br>当在保护代码中遇到异常时，可以通过<code>throw</code>关键字来将异常抛出</li><li><code>catch</code><br>跟在保护代码后面,<code>catch</code>关键字能够捕获<code>throw</code>抛出的异常，并根据异常的类型进行不同的处理</li></ul><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">division</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>( b == <span class="hljs-number">0</span> )<br>   &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Division by zero condition!&quot;</span>; <span class="hljs-comment">//throw抛出了const char*类型的异常</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> (a/b);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> x = <span class="hljs-number">50</span>;<br>   <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">double</span> z = <span class="hljs-number">0</span>;<br> <br>   <span class="hljs-keyword">try</span> &#123;<br>     z = <span class="hljs-built_in">division</span>(x, y);<br>     cout &lt;&lt; z &lt;&lt; endl;<br>   &#125;<span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg) &#123; <span class="hljs-comment">//catch捕获throw抛出的异常</span><br>     cerr &lt;&lt; msg &lt;&lt; endl; <span class="hljs-comment">//对异常进行处理</span><br>   &#125;<br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-异常类"><a href="#C-异常类" class="headerlink" title="C++异常类"></a>C++异常类</h2><p><code>throw</code>和<code>catch</code>既可以抛出和捕获基础类型的异常，也可以使用C++预定义的异常类，这些异常类有统一的的接口，便于我们进行异常的捕获和处理。</p><p>C++预定义的异常类包括：</p><ul><li><code>std::exception</code>：所有标准异常的基类。​<ul><li><code>std::bad_alloc</code>：内存分配失败时抛出。​</li><li><code>std::bad_cast</code>：动态类型转换失败时抛出。​</li><li><code>std::bad_typeid</code>：使用typeid运算符失败时抛出。​</li><li><code>std::bad_exception</code>：在函数声明中使用了异常规格，但抛出了未列出的异常时抛出（C++11已弃用）。​</li><li><code>std::logic_error</code>：逻辑错误异常基类，包括：​<ul><li><code>std::domain_error</code>：数学域错误，如sqrt(-1)。​</li><li><code>std::invalid_argument</code>：无效参数错误。​</li><li><code>std::length_error</code>：超出允许长度的错误。​</li><li><code>std::out_of_range</code>：范围错误，如访问vector的非法索引。​</li></ul></li><li><code>std::runtime_error</code>：运行时错误异常基类，包括：​<ul><li><code>std::overflow_error</code>：上溢错误。​</li><li><code>std::range_error</code>：范围错误（与std::out_of_range不同，用于其他情况）。​</li><li><code>std::underflow_error</code>：下溢错误。​<br>上面的异常类最常使用的核心接口<code>.what()</code>，返回<code>const char *</code>，用于说明异常的情况。</li></ul></li></ul></li></ul><p><strong>标准异常类的示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testLogicError</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid argument error!&quot;</span>);​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testRuntimeError</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range error!&quot;</span>);​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">try</span> &#123;​<br>        <span class="hljs-built_in">testLogicError</span>(); <span class="hljs-comment">// 抛出逻辑错误异常​</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> logic_error&amp; e) &#123;​<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught a logic_error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;​<br>    &#125;​<br>​<br>    <span class="hljs-keyword">try</span> &#123;​<br>        <span class="hljs-built_in">testRuntimeError</span>(); <span class="hljs-comment">// 抛出运行时错误异常​</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> runtime_error&amp; e) &#123;​<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught a runtime_error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;​<br>    &#125;​<br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，还可以通过继承<code>std::exception</code>并重载<code>what</code>来实现自定义的异常类。</p><p><strong>自定义异常类的示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br>​<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> : <span class="hljs-keyword">public</span> exception &#123;​<br><span class="hljs-keyword">public</span>:​<br>    <span class="hljs-built_in">MyException</span>(<span class="hljs-type">const</span> string&amp; message) : <span class="hljs-built_in">message_</span>(message) &#123;&#125;​<br>​<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> <span class="hljs-keyword">override</span> </span>&#123;​<br>        <span class="hljs-keyword">return</span> message_.<span class="hljs-built_in">c_str</span>();​<br>    &#125;​<br>​<br><span class="hljs-keyword">private</span>:​<br>    string message_;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testCustomException</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyException</span>(<span class="hljs-string">&quot;Custom exception occurred!&quot;</span>);​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">try</span> &#123;​<br>        <span class="hljs-built_in">testCustomException</span>(); <br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> MyException&amp; e) &#123;​<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught a MyException: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;​<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> exception&amp; e) &#123;​<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught an unknown exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;​<br>    &#125;​<br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a><code>noexcept</code></h2><p>从C++11开始，可以使用<code>noexcept</code>修饰函数，声明函数不会抛出任何异常，这有利于编译器做更多的优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// 声明函数不抛出任何异常​</span><br></code></pre></td></tr></table></figure><p>此外，<code>noexcept</code>还可以作为运算符，传入函数来验证某个函数是否被<code>noexcept</code>修饰</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">may_throw</span><span class="hljs-params">()</span></span>;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">no_throw</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>  <span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">may_throw</span>()); <span class="hljs-comment">// false​</span><br>  <span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">no_throw</span>()); <span class="hljs-comment">// true​</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类的析构函数默认是<code>noexcept</code>的</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的引用</title>
    <link href="/2025/06/09/cpp-reference/"/>
    <url>/2025/06/09/cpp-reference/</url>
    
    <content type="html"><![CDATA[<p>引用是一种特殊的变量别名机制，它</p><ul><li>是变量的别名，既不是变量本身，也不是变量的拷贝。</li><li>在定义时必须被初始化，且一旦被绑定到一个变量上，就不能再被绑定到另一个变量上，与指针相比更加安全（但也并非完全安全，引用也依赖于绑定对象的有效性，如果绑定的对象内存被释放，则引用的行为是未定义的）。</li><li>必须被绑定到有效的对象，不能为<code>nullptr</code>，这就可以天然地避免空指针的问题。</li><li>操作简单。</li></ul><h2 id="引用的作用"><a href="#引用的作用" class="headerlink" title="引用的作用"></a>引用的作用</h2><ul><li>作为别名<br>  可以简化复杂数据的访问  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>&#123;<br>    std::string name;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; grades;<br>&#125;<br>Person guts&#123;<span class="hljs-string">&quot;Guts&quot;</span>,&#123;<span class="hljs-number">80</span>,<span class="hljs-number">99</span>,<span class="hljs-number">59</span>&#125;&#125;;<br>std::string &amp; english_grade = guts.grades[<span class="hljs-number">2</span>];<br>english_grade++;<br></code></pre></td></tr></table></figure></li><li>作为参数传递<ul><li>避免拷贝开销</li><li>允许修改实参</li><li><code>const</code>引用作为参数也是有意义的，可以避免拷贝开销，并且<code>const</code>引用还可以绑定右值</li></ul></li><li>作为函数返回值<ul><li>可以用于链式调用，函数返回引用，引用又调用函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> MyClass&amp; obj) &#123;​<br>    os &lt;&lt; obj.<span class="hljs-built_in">data</span>();​<br>    <span class="hljs-keyword">return</span> os;  <span class="hljs-comment">// 允许链式调用</span><br>&#125;<br>std::cout &lt;&lt; obj1 &lt;&lt; obj2;<span class="hljs-comment">//等价于std::cout &lt;&lt; obj1.data() &lt;&lt; obj2.data();</span><br></code></pre></td></tr></table></figure></li><li>用于实现运算符的重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">MyClass&amp; MyClass::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;​<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;​<br>        <span class="hljs-comment">// 赋值操作​</span><br>    &#125;​<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用​</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>右值引用<br>右值引用<code>T&amp;&amp;</code>可以绑定右值(<code>const</code>引用也可以)，通常用于移动语义，避免深拷贝。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>&amp;&amp; x = <span class="hljs-number">42</span>;     <span class="hljs-comment">// 合法，右值引用绑定字面量（右值）</span><br><span class="hljs-type">int</span>&amp; y = <span class="hljs-number">42</span>;      <span class="hljs-comment">// 错误，左值引用不能绑定右值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; z = <span class="hljs-number">42</span>;<span class="hljs-comment">// 合法，const引用也可以绑定右值</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>    <span class="hljs-built_in">MyString</span>(MyString&amp;&amp; other) <span class="hljs-keyword">noexcept</span> ​<br>        : <span class="hljs-built_in">data_</span>(other.data_), <span class="hljs-built_in">size_</span>(other.size_) &#123;​<br>        other.data_ = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 转移资源所有权​</span><br>    &#125;​<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><code>const</code>引用<br><code>const</code>引用也可以绑定右值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(string&amp; a)</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; a)</span> </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;12323&quot;</span>);<span class="hljs-comment">//变异失败，因为string &amp;作为一个引用类型，必须要知道它绑定对象的地址才行，而输入值是const char*类型的右值</span><br>    <span class="hljs-built_in">func2</span>(<span class="hljs-string">&quot;12323&quot;</span>);<br>&#125; <br><br></code></pre></td></tr></table></figure></li></ul><h3 id="与指针的区别"><a href="#与指针的区别" class="headerlink" title="与指针的区别"></a>与指针的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;​<br>    <span class="hljs-comment">//代码段1</span><br>    <span class="hljs-type">int</span>&amp; ref = x;  <span class="hljs-comment">// 编译器等价处理为 int* const ref = &amp;x;​</span><br>    ref = <span class="hljs-number">20</span>;      <span class="hljs-comment">// 等价于 *ref = 20;​</span><br>    ​<span class="hljs-comment">//代码段2</span><br>    <span class="hljs-type">int</span>* ptr = &amp;x;​<br>    *ptr = <span class="hljs-number">30</span>;​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><p>代码段1和代码段2在生成的汇编代码中除了数字外完全一样，因为引用本质上是通过指针常量来实现的。</p><table><thead><tr><th align="left">特性</th><th align="left">引用</th><th align="left">指针</th></tr></thead><tbody><tr><td align="left">初始化要求</td><td align="left">必须初始化，且不可重新绑定到其他对象</td><td align="left">可以声明为空指针（<code>nullptr</code>），后续可修改指向</td></tr><tr><td align="left">空值合法性</td><td align="left">不允许空引用</td><td align="left">允许空指针（<code>nullptr</code>）</td></tr><tr><td align="left">内存占用</td><td align="left">不占用显式内存（编译器优化）</td><td align="left">占用独立内存（存储地址值）</td></tr><tr><td align="left">操作语法</td><td align="left">直接使用对象语法（无<code>＊</code>或 <code>-&gt;</code> ）</td><td align="left">需用<code>＊</code>解引用或 <code>-&gt;</code> 访问成员</td></tr><tr><td align="left">类型安全性</td><td align="left">强类型绑定，无类型转换风险</td><td align="left">允许 <code>void＊</code>和危险的类型转换</td></tr><tr><td align="left">多级间接访问</td><td align="left">仅支持单层引用（无引用的引用）</td><td align="left">支持多级指针（<code>int＊＊</code>）</td></tr><tr><td align="left">内存地址可见性</td><td align="left">无法直接获取引用的地址（<code>＆ref</code> 返回原对象地址）</td><td align="left">可直接获取指针变量的地址（<code>＆ptr</code>）</td></tr></tbody></table><ol><li>当需要指向空值或重新指向另一个对象时，使用指针。</li><li>当需要在函数间安全地传递大型对象或需要修改函数参数时，优先考虑引用（除非有指向空或重新指向的需求）。</li><li>在需要动态内存分配或管理内存时，使用指针。</li><li>在需要避免拷贝大型对象以提高效率时，使用引用（特别是作为函数参数或返回值）。</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的enum class</title>
    <link href="/2025/06/08/cpp-enum-class/"/>
    <url>/2025/06/08/cpp-enum-class/</url>
    
    <content type="html"><![CDATA[<h2 id="与enum的对比"><a href="#与enum的对比" class="headerlink" title="与enum的对比"></a>与<code>enum</code>的对比</h2><p>C++11之所以要引入<code>enum class</code>，是因为传统的<code>enum</code></p><ul><li>作用域不限范围，会造成命名空间的污染  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;black,white,red&#125;;<span class="hljs-comment">//black、white、red作用域和color作用域相同</span><br><br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>;<span class="hljs-comment">//错误，white已经被声明过了</span><br></code></pre></td></tr></table></figure>  而<code>enum class</code>的枚举成员默认具有强作用域，需要通过枚举类型名来访问，能够降低命名空间的污染  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span>&#123;black,white,red&#125;; <span class="hljs-comment">//black、white、red作用域仅在大括号内生效</span><br><br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>;<span class="hljs-comment">//正确，这个white并不是Color中的white</span><br><br>Color c = white;<span class="hljs-comment">//错误，在作用域范围内没有white这个枚举量</span><br><br>Color c = Color::white;<span class="hljs-comment">//正确</span><br><br><span class="hljs-keyword">auto</span> c = Color::white;<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li>会发生隐式类型转换  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;black,white,red&#125;;<br><span class="hljs-function">std::vector&lt;std::<span class="hljs-type">size_t</span>&gt; <span class="hljs-title">primeFactors</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> x)</span></span>;<span class="hljs-comment">//函数返回x的质因数</span><br><br>Color c = red;<br><br><span class="hljs-keyword">if</span>(c &lt; <span class="hljs-number">14.5</span>)<span class="hljs-comment">//将color型别和double型别比较，发生隐式转换</span><br>&#123;<br>    <span class="hljs-keyword">auto</span> factors = <span class="hljs-built_in">primeFactors</span>(c);  <span class="hljs-comment">//计算一个color型别的质因数，发生隐式转换</span><br>&#125;<br></code></pre></td></tr></table></figure>  而<code>enum class</code>的元素只能通过<code>static_cast</code>进行强制类型转换</li><li>不能进行前置声明，而<code>enum class</code>可以  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>;<span class="hljs-comment">//错误</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span>;<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/weixin_42817477/article/details/109029172">[CSDN]C++11枚举类——enum class</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的const关键字</title>
    <link href="/2025/06/08/cpp-const/"/>
    <url>/2025/06/08/cpp-const/</url>
    
    <content type="html"><![CDATA[<h2 id="const关键字的使用"><a href="#const关键字的使用" class="headerlink" title="const关键字的使用"></a><code>const</code>关键字的使用</h2><p><code>const</code>关键字可以修饰C++的内置变量、指针、自定义对象、成员函数、返回值和函数参数，以告诉编译器某些值需要保持不变的。也就是说，<code>const</code>关键字是在编译过程中发挥作用的。</p><h3 id="const修饰普通类型的变量"><a href="#const修饰普通类型的变量" class="headerlink" title="const修饰普通类型的变量"></a><code>const</code>修饰普通类型的变量</h3><p>当一个变量被<code>const</code>修饰时，程序不能改变这个变量的值</p><h3 id="const修饰指针变量"><a href="#const修饰指针变量" class="headerlink" title="const修饰指针变量"></a><code>const</code>修饰指针变量</h3><p><code>const</code>修饰指针变量时，情况会变复杂，有三种情况</p><ol><li><code>const</code>修饰指针指向的内容<br>此时该指针指向的内容是不可修改的，更准确的说，是<strong>不能通过这个指针来修改它指向的内容</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p = &amp;a;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> * p = &amp;a;<span class="hljs-comment">//两种写法等价</span><br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">//错误的</span><br>a = <span class="hljs-number">9</span>;<span class="hljs-comment">//正确的</span><br></code></pre></td></tr></table></figure></li><li><code>const</code>修饰指针<br>即指针常量，指针不能修改 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;<br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span>  b = <span class="hljs-number">7</span>;<br>p = &amp;b; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure></li><li><code>const</code>修饰指针和指针指向的内容<br>则既不能通过指针修改指向的内容，也不能修改指针本身 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span>  p = &amp;a;<br></code></pre></td></tr></table></figure>为了更好地理解上述的三种情况为什么这样声明，推荐阅读<a href="https://cseweb.ucsd.edu/~gbournou/CSE131/rt_lt.rule.html">C Right-Left Rule (Rick Ord’s CSE 131</a></li></ol><h3 id="const修饰函数参数和返回值"><a href="#const修饰函数参数和返回值" class="headerlink" title="const修饰函数参数和返回值"></a><code>const</code>修饰函数参数和返回值</h3><p><code>const</code>修饰函数参数时，参数在函数体内无法被修改。最常见的情况是用<code>const</code>修饰指针防止其被意外篡改，以及<code>const</code>+引用传递以免去自定义类型在值传递时构造临时对象的开销。</p><!-- 要理清`const`修饰函数返回值对返回值的影响，首先要明白在C/C++中，函数的返回值总是**按值**返回的，函数会把返回值复制到一个外部的临时变量`a`，这个变量时可以被拷贝的。如果有在函数被调用后，有外部变量`b`能够“接住”`a`，那么`a`会被拷贝到`b`（对于自定义的变量，则会调用赋值构造函数），然后将`a`释放，如果没有变量“接住”`a`，则直接释放。接下来我们分析`const`修饰函数返回值时，三种不同的情况 --><p><code>const</code>修饰函数返回值时，有下面三种不同的情况</p><ol><li>修饰内置类型的返回值<br>返回的是一个临时变量，<code>const</code>修饰没有实际意义，与不修饰时一样</li><li>修饰自定义类型的返回值<br>则返回值不能作为左值使用，既不能被赋值也不能被修改.同时也不能调用返回对象的非<code>const</code>成员函数</li><li>修饰指针或引用类型的返回值<ul><li>函数返回指向常量的指针   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p =<span class="hljs-built_in">func</span>();<br>*p = <span class="hljs-number">10</span>;       <span class="hljs-comment">// 错误</span><br>p++; <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li>函数返回指针常量  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = <span class="hljs-built_in">func</span>();<br>*p = <span class="hljs-number">10</span>;       <span class="hljs-comment">//正确</span><br>p++;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li>函数返回指向常量的指针常量  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = <span class="hljs-built_in">func</span>();<br>*p = <span class="hljs-number">10</span>;       <span class="hljs-comment">//错误</span><br>p++;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><code>const</code>修饰引用返回值<br> 返回一个只读的引用  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> MyClass&amp; <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> MyClass&amp; ref = <span class="hljs-built_in">func</span>();<br>ref.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="const修饰类的成员函数"><a href="#const修饰类的成员函数" class="headerlink" title="const修饰类的成员函数"></a><code>const</code>修饰类的成员函数</h3><p>在成员函数的标识符后面修饰，保证在调用过程中不会修改对象中任何没有<code>mutable</code>修饰的成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> _m):_cm(_m)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_cm</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">return</span> _cm;<br>    &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _cm;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：<code>const</code>关键字不能与<code>static</code>关键字同时使用，因为<code>static</code>关键字修饰静态成员函数，静态成员函数不含有<code>this</code>指针，即不能实例化，<code>const</code>成员函数必须具体到某一实例。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><code>volatile</code>关键字</h2><p><code>volatile</code>修饰的变量表示其可以被某些编译器未知的因素修改。例如</p><ul><li>操作系统</li><li>硬件</li><li>其他的线程<br>这样编译器就不会对<code>volatile</code>修饰的变量进行优化。例如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a = i;<br>...<br><span class="hljs-comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span><br><span class="hljs-type">int</span> b = i;<br></code></pre></td></tr></table></figure><p>在上面的代码中，无论是将<code>i</code>赋值给<code>a</code>还是<code>b</code>，都要从<code>i</code>的地址中读取值，而如果<code>i</code>没有被<code>volatile</code>修饰，那么编译器就会优化对<code>b</code>的赋值，直接将上次从<code>i</code>的地址中读取的值赋值给<code>b</code>,而不是重新读取<code>i</code>的地址中的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>上面的代码也是合法的，·且<code>const</code>和<code>volatile</code>关键字都能发挥作用</p><ul><li>在<code>a</code>的作用域内，无法对<code>a</code>进行修改，因为它是<code>const</code>修饰的</li><li>但是<code>a</code>的值可能被其他线程或者别的外部事件改变，因为它是<code>volatile</code>修饰的</li></ul><h2 id="mutable关键字"><a href="#mutable关键字" class="headerlink" title="mutable关键字"></a><code>mutable</code>关键字</h2><p><code>mutable</code>关键字用于修饰类的成员变量。</p><ul><li>当成员变量被<code>mutable</code>修饰时，表示该变量时可变的，即使包含它的对象被声明为<code>const</code>类型</li><li><code>mutable</code>修饰成员变量不会影响其在类外部的可见状态</li></ul><h2 id="const与-define的区别"><a href="#const与-define的区别" class="headerlink" title="const与#define的区别"></a><code>const</code>与<code>#define</code>的区别</h2><ul><li><code>#define</code>是预处理指令，在预处理阶段对宏定义进行分析和替换，而<code>const</code>是关键字，是由编译器在编译阶段处理的</li><li><code>#define</code>没有作用域的限制（但也得在<code>#define</code>后使用啊不然就违反因果律了），宏可以被定义在当前程序的任意位置或者被其包含的头文件中，只有遇到对应的<code>#undef</code>才失效。而<code>const</code>修饰的变量有作用域的限制。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> definePI &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.1415926</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> pi = <span class="hljs-number">3.1415926</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, PI);      <span class="hljs-comment">// 输出3.1415926</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, pi);      <span class="hljs-comment">// 编译错误</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> PI</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, PI);      <span class="hljs-comment">// 编译错误</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, E);       <span class="hljs-comment">// 编译错误</span><br>&#125;<br><br><span class="hljs-keyword">namespace</span> defineE &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> E 2.7182818</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><code>#define</code>可以重定义（需要先<code>#undef</code>取消定义）但是<code>const</code>不行  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> X 30</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Y=<span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of X: &quot;</span>&lt;&lt;X&lt;&lt;endl; <span class="hljs-comment">//输出30</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> X</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> X 300</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of X: &quot;</span>&lt;&lt;X&lt;&lt;endl; <span class="hljs-comment">//输出300</span><br>    <br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of Y: &quot;</span>&lt;&lt;Y&lt;&lt;endl; <span class="hljs-comment">//输出10</span><br>    Y=<span class="hljs-number">100</span>;<span class="hljs-comment">//error, we can not assign value to const</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of Y: &quot;</span>&lt;&lt;Y&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><code>constexpr</code></h2><p><code>constexpr</code>在C++11中被引进，字面意思是<code>const expression</code>。<code>constexpr</code>修饰的变量是编译期常量，且必须用常量表达式初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mf = <span class="hljs-number">20</span>;              <span class="hljs-comment">//正确，20是常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> limit = mf + <span class="hljs-number">1</span>;       <span class="hljs-comment">//正确，mf + 1是常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> sz = <span class="hljs-built_in">size</span>();         <span class="hljs-comment">//未知，若size()函数是一个constexpr函数时即正确，反之错误。</span><br><br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> t = i;                <span class="hljs-comment">//错误，i不是常量</span><br></code></pre></td></tr></table></figure><h3 id="literal-type"><a href="#literal-type" class="headerlink" title="literal type"></a><code>literal type</code></h3><p><code>constexpr</code>只能用于修饰<code>literal type</code>的变量，一个变量是<code>literal type</code>当且仅当它属于下面的类型</p><ul><li>标量类型 <a href="https://en.cppreference.com/w/cpp/named_req/ScalarType.html">scalar type</a><br>包含<ul><li>算数类型</li><li>枚举类型</li><li>指针类型</li><li>指向类成员的指针类型</li><li><code>std::nullptr_t</code></li><li>以上类型的<code>cv</code>限定版本（即用<code>const</code>或<code>volatile</code>修饰的版本）</li></ul></li><li>引用</li><li><code>literal type</code>的数组</li><li>具有以下所有性质的<code>cv-qualified</code>类<ul><li>拥有平凡(<code>trivial</code>)析构函数（即默认析构函数）（C++20前的版本）或<code>constexpr</code>析构函数(C++20)</li><li>所有非静态且非<code>variant</code>的成员（<code>variant</code>变量在编译时无法确定变量的具体类型）和基类都不是<code>volatile</code>修饰的<code>literal type</code>, 并且是下面几种类型之一<ul><li><code>lambda</code>类型</li><li>满足下列条件的聚合<code>union</code><ul><li>没有<code>variant</code>成员</li><li>或者至少有一个非<code>volatile</code>修饰的<code>literal type</code>的<code>variant</code>成员</li></ul></li><li>非<code>union</code>的聚合类型，并且每个匿名联合体成员也都满足<ul><li>没有<code>variant</code>成员</li><li>或者至少有一个非<code>volatile</code>修饰的<code>literal type</code>的<code>variant</code>成员</li></ul></li><li>具有至少一个<code>constexpr</code>构造函数的类型，且该构造函数不是拷贝或移动构造函数</li></ul></li></ul></li></ul><h3 id="与const的区别"><a href="#与const的区别" class="headerlink" title="与const的区别"></a>与<code>const</code>的区别</h3><ul><li><code>const</code>修饰的变量可以在运行时才初始化，而<code>constexpr</code>则一定会在编译期初始化。​</li><li>而<code>const</code>表示的是read only的语义，只保证修饰的变量运行时不可以被直接更改，并未区分是编译期常量还是运行期常量。​</li></ul><h3 id="constexpr指针"><a href="#constexpr指针" class="headerlink" title="constexpr指针"></a><code>constexpr</code>指针</h3><p><code>constexpr</code>只对指针本身有效，而不会对指针指向的对象生效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;            <span class="hljs-comment">//正确，p是一个指向整型常量的指针, p本身可以被修改，但是p指向的内存无法通过p来修改</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *q = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">//正确，但q是一个指向  整数  的  常量指针，q无法被修改</span><br></code></pre></td></tr></table></figure><p>一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或者<code>0</code>，或者是指向存储于某个固定地址中的对象。</p><h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a><code>constexpr</code>函数</h3><p><code>constexpr</code>修饰的函数要求其返回类型以及所有的形参都是<code>literal type</code>，且函数体中必须有且仅有一条<code>return</code>语句(除非函数的返回值是<code>void</code>)。这样在它们被调用时，编译期会把它们直接展开替换为结果值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<span class="hljs-comment">//constexpr函数</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> foo = <span class="hljs-built_in">new_sz</span>();<br><span class="hljs-comment">//在对变量foo初始化时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</span><br></code></pre></td></tr></table></figure><p>有意思的是，C++允许<code>constexpr</code>返回的值不是常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//如果cnt是常量表达式，则scale(cnt)也是常量表达式</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">size_t</span> cnt)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">new_sz</span>() * cnt; &#125;<br><br><span class="hljs-comment">//当scale的实参是常量表达式时，它的表达式也是常量表达式，反之则不然</span><br><span class="hljs-type">int</span> arr[<span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>)];<span class="hljs-comment">//正确：scale(2)是常量表达式</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<span class="hljs-comment">//i不是常量表达式</span><br><span class="hljs-type">int</span> a2[<span class="hljs-built_in">scale</span>(i)];<span class="hljs-comment">//错误：scale(i)不是常量表达式</span><br></code></pre></td></tr></table></figure><p>前面提到返回值类型为<code>void</code>的函数也可以用<code>constexpr</code>来修饰，乍一看这样的函数没有任何意义，但实际上<code>constexpr</code>修饰的函数除了返回值是编译期常量外，还在编译期运行，这样就能在编译期执行一些操作。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>数组大小、模板参数和<code>switch</code>语句都要求编译期常量，使用<code>constexpr</code>修饰的变量或函数可以用于这些场景。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cn = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> arr[n]; <span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span> arr[cn]; <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">[RUNOOB] C++ const 关键字小结</a></li><li><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">[RUNOOB] C&#x2F;C++ 中 volatile 关键字详解</a></li><li><a href="https://en.cppreference.com/w/cpp/keyword/const.html">[cppreference.com] C++ keyword: const</a></li><li><a href="https://en.cppreference.com/w/cpp/language/cv.html">[cppreference.com] cv (const and volatile) type qualifiers</a></li><li><a href="https://en.cppreference.com/w/cpp/keyword/volatile.html">[cppreference.com] C++ keyword: volatile</a></li><li><a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">[cppreference.com] C++ named requirements: LiteralType (since C++11)</a></li><li><a href="https://www.cnblogs.com/ljwgis/p/13095739.html">[cnblog] C++11新特性：constexpr变量和constexpr函数</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的inline关键字</title>
    <link href="/2025/06/08/cpp-inline/"/>
    <url>/2025/06/08/cpp-inline/</url>
    
    <content type="html"><![CDATA[<p><code>inline</code>关键字会向编译器发出一个请求（而非命令，编译器可以选择拒绝），建议将函数体在调用点处内联展开，以减少函数的调用开销（例如栈帧的创建、参数的传递等）。</p><ul><li><code>inline</code>函数通常用于执行速度快且调用频繁的小函数</li><li><code>inline</code>函数的定义通常放在头文件中</li><li><code>inline</code>函数不能包含复杂的控制结构，例如循环和递归</li><li>编译器可能会忽略<code>inline</code>关键字，一般是<ul><li>函数体较大</li><li>包含复杂逻辑</li><li>编译器的优化级别较低，在编译时比较保守</li><li>编译器的优化策略决定</li></ul></li><li>可以通过在汇编代码查看代码是否内联，被内联的函数不会有函数标签</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的内存管理</title>
    <link href="/2025/06/07/memory/"/>
    <url>/2025/06/07/memory/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>栈内存是由<strong>编译器自动管理</strong>的内存区域，用于存储局部变量、函数参数和返回地址等。栈内存的分配和释放是自动进行的：</p><ul><li>当函数被调用时，局部变量和参数会被压入栈中</li><li>当函数返回时，这些局部变量和参数会被弹出栈并释放。<br>栈内存的大小固定，一般为8M左右，无法动态调整。作用域一般是函数内部，函数返回时会自动释放。</li></ul><p>分配速度快。</p><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>栈溢出最典型的情况就是无限递归调用导致溢出，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 无限递归调用</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回地址与栈攻击"><a href="#返回地址与栈攻击" class="headerlink" title="返回地址与栈攻击"></a>返回地址与栈攻击</h4><p>在函数调用过程中，当前函数执行完成后应返回调用者的位置，这个位置称之为返回地址。</p><p>由于返回地址是由编译器自动管理的，其在栈内存上往往与编译器为函数内局部变量分配的内存相邻，因此攻击者可以利用这一特性，向固定大小的缓冲区写入超长的数据，覆盖返回地址，使程序跳转到提前布置好的恶意代码，这是一种典型的栈溢出攻击。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vulnerable</span><span class="hljs-params">(<span class="hljs-type">char</span> *input)</span> </span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">16</span>];<br>    <span class="hljs-built_in">strcpy</span>(buf, input); <span class="hljs-comment">// 无边界检查,如果输入超过16字节，就可能覆盖返回地址，跳转到攻击者布置的shellcode。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>堆内存是由程序员手动管理的内存区域。大小不固定，可以动态调整，但任意出现内存泄露等问题。</p><p>作用域由程序员控制，只要不释放内存就一直存在。</p><p>与栈内存相比分配速度较慢。</p><h3 id="变量和存储区"><a href="#变量和存储区" class="headerlink" title="变量和存储区"></a>变量和存储区</h3><img src="/2025/06/07/memory/memory.jpg" class="" title="C++的内存分区"><p>c++程序的内存分为4个区域</p><ul><li><strong>代码段</strong> 存储代码的指令，只读</li><li><strong>数据段</strong><br>存储<strong>全局变量</strong>和<strong>静态变量</strong>，分为 <ul><li><p>已初始化的数据区<br>进一步分为</p><ul><li>已初始化的只读区域<br>存储<code>const</code>修饰的全局变量、常量字符串等，例如<code>const char* str = &quot;hello world&quot;</code>这行代码中<code>&quot;hello world&quot;</code>存储在已初始化的只读区域，<code>str</code>放在已初始化的读写区域(注意<code>const char* str</code>是 “指向常量的指针”，所以它<code>str</code>还可以修改，只是不能通过它去修改指向的内容。)</li><li>已初始化的读写区域</li></ul></li><li><p>未初始化的数据区（Block Started by Symbol，BSS）<br>存储未初始化或初始化为0的全局变量和静态变量</p></li></ul></li><li><strong>堆区</strong></li><li><strong>栈区</strong></li></ul><h3 id="内存泄露与悬空指针"><a href="#内存泄露与悬空指针" class="headerlink" title="内存泄露与悬空指针"></a>内存泄露与悬空指针</h3><ul><li>内存泄漏指的是程序没有主动释放不再使用的内存，导致内存的占用不断增加。为了防止内存泄露，需要在不再使用内存时将其及时释放。</li><li>悬空指针指的则是指向了已经释放的内存的指针，<strong>为了避免悬空指针，应该在释放内存后，将指向它的指针置为<code>nullptr</code></strong></li></ul><h2 id="堆内存的使用"><a href="#堆内存的使用" class="headerlink" title="堆内存的使用"></a>堆内存的使用</h2><h3 id="malloc和free"><a href="#malloc和free" class="headerlink" title="malloc和free"></a><code>malloc</code>和<code>free</code></h3><ul><li><a href="https://en.cppreference.com/w/cpp/memory/c/malloc">std::malloc</a><br>用于在堆上分配指定大小的内存块  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure>返回指向分配的内存的指针，若分配失败，则返回<code>nullptr</code></li><li><code>calloc</code><br>分配内存并初始化（将所有的字节都置0）   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num, <span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure><ul><li><code>num</code>要分配的元素的个数</li><li><code>size</code>元素的大小（字节数）</li></ul></li><li><code>realloc</code><br>调整已分配的内存块的大小   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure><ul><li><code>ptr</code>要调整的内存块的指针</li><li><code>size</code>新的内存块大小（字节数）</li><li>返回指向新的内存块的指针，若分配失败，返回<code>nullptr</code>，原来的内存块（<code>ptr</code>）保持原样。<ul><li><p>分配失败可能会导致内存泄露</p><blockquote><p>If there is not enough memory, the old memory block is not freed and null pointer is returned.——<a href="https://en.cppreference.com/w/c/memory/realloc">cppreference</a></p></blockquote><p>需要手动处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">        <span class="hljs-type">int</span>* ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>`(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);​<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>) &#123;​<br>    <span class="hljs-comment">// 处理内存分配失败​</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 或采取其他错误处理​</span><br>&#125;​<br>​<br><span class="hljs-comment">// 使用临时指针保存realloc结果​</span><br><span class="hljs-type">int</span>* temp = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(ptr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">20</span>);​<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;​<br>    <span class="hljs-comment">// realloc失败：原始内存仍可通过ptr访问​</span><br>    <span class="hljs-built_in">free</span>(ptr);   <span class="hljs-comment">// 释放原始内存（可选）​</span><br>    ptr = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 避免悬空指针​</span><br>    <span class="hljs-comment">// 处理错误（例如退出或降级使用）​</span><br>&#125; <span class="hljs-keyword">else</span> &#123;​<br>    ptr = temp; <span class="hljs-comment">// realloc成功，更新ptr​</span><br>    <span class="hljs-comment">// 现在ptr指向20个int的内存​</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><code>free</code><br>释放通过<code>malloc</code>,<code>calloc</code>和<code>realloc</code>分配的内存空间  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢"><a href="#为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢" class="headerlink" title="为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢?"></a>为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢?</h4><p>因为<code>malloc(size)</code>在分配内存时，除了会分配一部分大小为<code>size</code>的内存供程序员使用外，还会在这部分内存头部添加这块内存的元数据，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mem_control_block</span> &#123;<br>  <span class="hljs-type">int</span> is_available; <br>  <span class="hljs-type">int</span> size;        <br>&#125;;<br></code></pre></td></tr></table></figure><p>这样<code>free</code>这块内存的时候就可以访问这块区域进而获取需要free的内存大小。</p><!-- #### malloc的底层实现 --><h3 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a><code>new</code>和<code>delete</code></h3><ul><li><code>new</code>用于在堆上分配内存，并触发对象的构造函数，返回指向这块内存的指针</li><li><code>delete</code>则会触发对象的析构函数，并释放由<code>new</code>分配的内存</li><li><code>new[]</code>用于在堆上分配数组内存</li><li><code>delete[]</code>用于释放<code>new[]</code>分配的内存</li><li><code>new</code>和<code>delet</code>，<code>new[]</code>和<code>delete[]</code>需要配对使用，否则会导致未定义行为</li><li><code>placement new</code>允许在已分配的内存上构造对象，而不会分配新的内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br>​<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;​<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a): <span class="hljs-built_in">a_</span>(a) &#123;&#125;​<br>​<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;​<br>        std::cout &lt;&lt; a_ &lt;&lt; std::endl;​<br>    &#125;​<br>    <span class="hljs-type">int</span> a_;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">char</span>* buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)];​<br>​    <br>    A* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">9</span>);<br>    <span class="hljs-comment">// placement new在 buffer 上构造 A 对象​</span><br>    A* p1 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>);​<br>    p1-&gt;<span class="hljs-built_in">print</span>();​<br>​<br>    <span class="hljs-comment">// 显式调用析构函数​</span><br>    p1-&gt;~<span class="hljs-built_in">A</span>();​<br>​<br>    <span class="hljs-comment">// 释放内存​</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">delete</span>[] buffer;​<br>    p = <span class="hljs-literal">nullptr</span>;<br>    buffer = <span class="hljs-literal">nullptr</span>;<br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="new和delete的实现"><a href="#new和delete的实现" class="headerlink" title="new和delete的实现"></a><code>new</code>和<code>delete</code>的实现</h4><p>在上面的代码中，<code>A * p = new A(9)</code>包含下面的步骤</p><ul><li>调用C++标准库<strong>函数</strong><code>operator new</code>(如果是<code>new []</code>则调用的是<code>operator new []</code>)为<code>A</code>分配一块原始的内存</li><li>调用<code>A</code>的构造函数，在这块内存上构造对象</li><li>返回指向刚刚构造的<code>A</code>对象的指针</li></ul><p>需要注意的是，如果类<code>A</code>重载了<code>operator new</code>，则会调用<code>A::operator new(size_t size)</code>，否则调用全局函数<code>::operator new(size_t size)</code>。</p><p>运行<code>delete p</code>时，则会进行下面的操作</p><ul><li>调用<code>p</code>指向对象的析构函数</li><li>调用C++标准库<strong>函数</strong><code>operator delete</code>来释放该对象的内存，传入其的参数为<code>p</code>的值，即对象的地址。</li></ul><p><code>operator new</code>和<code>operator delete</code>的函数原型如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;     <span class="hljs-comment">//allocate an object</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span>;    <span class="hljs-comment">//free an object</span><br><br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>);     <span class="hljs-comment">//allocate an array</span><br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span> *);    <span class="hljs-comment">//free an array</span><br></code></pre></td></tr></table></figure><h4 id="new-和delete-的实现"><a href="#new-和delete-的实现" class="headerlink" title="new []和delete []的实现"></a><code>new []</code>和<code>delete []</code>的实现</h4><p>与<code>new</code>和<code>delete</code>类似，<code>new []</code>和<code>delete []</code>会分别调用<code>operator new []</code>和<code>operator delete []</code>来分配和释放内存。<code>new[]</code>会调用类的构造函数依次构造数组中的每个对象，<code>delete []</code>则会调用析构函数依次将所有的对象析构。</p><p>与<code>new</code>和<code>delete</code>不同的是，<code>new []</code>在为数组分配空间时，会额外分配4字节的空间来保存数组的长度，这4个字节会放在数组内存的前面，在调用<code>delete []</code>就会读取这4个字节以确定数组的长度。</p><p>因此<code>void * operator delete[] (void *)</code>接受的参数不是指向数组的指针，而是指向数组的指针减4个字节的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">string *ps = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span> [] ps;<br></code></pre></td></tr></table></figure><p>以上面的代码为例，<code>delete [] ps</code>调用<code>operator delete[] (void *)</code>时，传入<code>operator delete[]</code>的参数不是<code>ps</code>而是<code>ps</code>的值减4(前移4字节，而不是<code>ps-4</code>，前移4个<code>string</code>的大小)。</p><p>对于不需要调用析构函数的对象（例如<code>int</code>等内置类型），<code>new[]</code>时不会额外多分配4个字节，<code>delete []</code>直接调用<code>operator delete[]</code>，传入的地址也不用前移4个字节，因此如果是用<code>new[]</code>分配内置类型的数组，是可以使用<code>delete</code>来释放的。</p><h4 id="new-和delete-不配对使用的后果"><a href="#new-和delete-不配对使用的后果" class="headerlink" title="new[]和delete[]不配对使用的后果"></a><code>new[]</code>和<code>delete[]</code>不配对使用的后果</h4><h5 id="1-new-和delete配对使用"><a href="#1-new-和delete配对使用" class="headerlink" title="1. new[]和delete配对使用"></a>1. <code>new[]</code>和<code>delete</code>配对使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span> &#123;​<br>  <span class="hljs-keyword">public</span>:​<br>  <span class="hljs-built_in">inner</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Constructing&quot;</span> &lt;&lt; endl; &#125;​<br>  ~<span class="hljs-built_in">inner</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Destructing&quot;</span> &lt;&lt; endl; &#125;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;​<br>  inner *p = <span class="hljs-keyword">new</span> inner[<span class="hljs-number">2</span>];​<br>  <span class="hljs-keyword">delete</span> p;​<br>  p = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br>​<span class="hljs-comment">/*</span><br><span class="hljs-comment">程序输出：​</span><br><span class="hljs-comment">Constructing​</span><br><span class="hljs-comment">Constructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">munmap_chunk(): invalid pointer​</span><br><span class="hljs-comment">Aborted (core dumped)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>程序在调用了1次析构函数后挂掉。这是因为<code>delete</code>不会访问<code>p</code>的前4个字节获取长度，只调用了1次析构函数。并且<code>delete</code>传入<code>operator delete</code>的参数是<code>p</code>而不是<code>p</code>的值减4，而<code>p</code>的值减4才是一块内存的起始地址，释放内存时不从起始地址开始会出现段错误，从而导致程序整个挂掉</p><h5 id="2-new和delete-配对使用"><a href="#2-new和delete-配对使用" class="headerlink" title="2. new和delete[]配对使用"></a>2. <code>new</code>和<code>delete[]</code>配对使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span> &#123;​<br>  <span class="hljs-keyword">public</span>:​<br>  <span class="hljs-built_in">inner</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Constructing&quot;</span> &lt;&lt; endl; &#125;​<br>  ~<span class="hljs-built_in">inner</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Destructing&quot;</span> &lt;&lt; endl; &#125;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;​<br>  inner *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">inner</span>();​<br>  <span class="hljs-keyword">delete</span> []p;​<br>  p = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br>​<span class="hljs-comment">/*</span><br><span class="hljs-comment">程序输出：​</span><br><span class="hljs-comment">Constructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">...​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">free(): invalid pointer​</span><br><span class="hljs-comment">Aborted (core dumped)​</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>程序调用了<strong>不定次数</strong>的析构函数然后挂掉。这是因为<code>delete [] p</code>会往前4个字节去取数组的长度，而<code>new</code>并没有申请这4个字节的内存，因此这4个字节的内容是未知的，进而导致调用析构函数的次数是未知的。最后释放内存时使用的地址也是<code>p</code>的值减4而非正确的起始地址<code>p</code>，进而导致程序挂掉。</p><h3 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a><code>malloc</code>和<code>new</code>的区别</h3><ul><li><code>malloc</code>是C的库函数而<code>new</code>是C++运算符</li><li><code>malloc</code>返回<code>void *</code>，而<code>new</code>返回具体类型的指针</li><li>内存分配失败时，<code>malloc</code>返回<code>NULL</code>而<code>new</code>则会抛出<code>std::bad_alloc</code>异常</li><li><code>malloc</code>在使用时需要手动计算内存大小，而<code>new</code>不需要</li><li><code>new</code>会调用构造函数，而<code>malloc</code>不会</li><li><code>new</code>可以重载（可以重载<code>operator new</code>而非<code>new operator</code>），而<code>malloc</code>不行</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的指针</title>
    <link href="/2025/06/06/cpp-pointer/"/>
    <url>/2025/06/06/cpp-pointer/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>指针本质上也是一种变量，不过它存储的是对应变量类型的地址。</p><h3 id="为什么要有指针"><a href="#为什么要有指针" class="headerlink" title="为什么要有指针"></a>为什么要有指针</h3><!-- 笔者在学习指针时，一直有一个疑惑，那就是变量本身就包含地址，那为什么还需要指针呢？想来如果解释了这个问题，就解释了指针在C++中发挥的作用。* 首先, 我们拿到地址后，我们可以用地址做什么？  * 修改这个地址对应内存的值  似乎有些脱裤子放屁了，用变量本身就可以做到  * 对于一些很大的变量（类和结构体），值传递会有很大的复制开销，我们可以通过传递地址来减少这部分开销。  * 我们可以通过地址，访问邻近的变量*  --><p>之所以要有指针，是因为虽然变量本身就包含了地址的信息（不然我们也没法通过<code>&amp;</code>来取址），但变量和其地址之间的关系是一一对应的且无法修改的，无法满足我们对地址本身进行处理的需求。例如如果我们要实现数组的数据结构，将数据放入连续的内存中，那么我们需要解决下面的问题</p><ol><li>这块连续内存的起始地址是什么？</li><li>访问数组中的某个元素时，我们该如何确定它的地址？<br>假如这个元素的索引是<code>i</code>，数组中的元素大小都是<code>T</code>，那么我们访问它的时候就需要通过<code>首地址+i*T</code>来获取它的地址。</li></ol><p>那么问题来了，地址本身是个整型数据，为什么我们不直接使用<code>int</code>等整型类型来存储和操作呢？</p><ul><li>首先，需要维护一个额外的变量来告诉我们这个地址对应的变量大小，否则我们没法对这个地址取值，也没办法进行前面提到的数组寻址操作</li><li>其次，这样写的代码可读性很差</li><li>再者，不同平台的地址大小不同，如果我们在32位系统中使用<code>int</code>来存储地址，那么这部分代码就无法在64位的系统中运行<br>因此，定义一种新的变量来存储和操作地址是很有必要的。</li></ul><h3 id="指针的基本操作"><a href="#指针的基本操作" class="headerlink" title="指针的基本操作"></a>指针的基本操作</h3><ul><li>赋值和初始化  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p = &amp;a; <br></code></pre></td></tr></table></figure></li><li>解引用<br>指针通过<code>*</code>操作符获取指向的内存中存储的值，值的类型由指针的类型确定</li><li>指针运算<ul><li>加减运算<ul><li><code>T*</code>类型的指针<code>p + i</code>相当于<code>p</code>向前移动了<code>i * sizeof(T)</code>个字节</li><li>支持<code>++</code>和<code>--</code></li></ul></li><li>比较运算<br>比较两个指针的值，也就是比较两个地址是否相同</li></ul></li></ul><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>数组名本质是指向数组首地址的、<strong>不可修改</strong>的常量指针。在作为函数参数时，它会退化为指向数组首元素的指针，这时候可以对它进行自增等运算。</p><ul><li><code>int (*p)[10]</code>表示这是一个指向长度为10的<code>int</code>数组的指针，其类型为<code>int (*)[]</code>。也就是说<code>p++</code>会令<code>p</code>向前移动40个字节</li><li><code>int *p[10]</code>表示这是一个包含了10个<code>int*</code>变量的数组。作为函数参数退化为指针后，它的类型是<code>int**</code></li></ul><!-- ### 指针与动态数组 --><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>每个函数都有一个唯一的入口地址，函数指针存储的就是这个地址。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//返回类型 (*指针名)(函数参数列表);</span><br><span class="hljs-built_in">int</span> (*funcPtr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>这里的<code>funcPtr</code>就是一个指向函数的指针，接受两个<code>int</code>参数并返回<code>int</code>值。</p><h3 id="赋值与调用"><a href="#赋值与调用" class="headerlink" title="赋值与调用"></a>赋值与调用</h3><ul><li>函数名在大多数情况下都会被编译器解释为函数的地址，因此可以直接用函数名给函数指针赋值。</li><li>函数指针的调用方式与函数名的调用方式一致</li><li>基于提高可读性的目的，可以使用<code>typedef</code>来封装函数指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;​<br>    <span class="hljs-keyword">return</span> a + b;​<br>&#125;​<br>​<br><span class="hljs-comment">// 封装后的函数指针类型​</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*FuncPtr)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-comment">// 声明一个函数指针变量​</span><br>    FuncPtr fp = add;​<br>​<br>    <span class="hljs-comment">// 通过函数指针调用函数​</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">fp</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);​<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result: %d\n&quot;</span>, result);  <span class="hljs-comment">// 输出: Result: 7​</span><br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>指针函数是返回指针的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>注意和函数指针的区别在于是否有括号将*+标识符包裹起来，关于C&#x2F;C++中的声明规则，可以阅读<a href="https://cseweb.ucsd.edu/~gbournou/CSE131/rt_lt.rule.html">C Right-Left Rule (Rick Ord’s CSE 131</a></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>通过回调函数，程序在运行时可以动态地决定调用哪个函数。这常常用于事件处理和异步编程的场景中，例如GUI编程中的按钮和ROS中对topic的订阅都会绑定对应的回调函数。在C语言中，回调函数通过函数指针来实现。</p><h4 id="回调函数的实现"><a href="#回调函数的实现" class="headerlink" title="回调函数的实现"></a>回调函数的实现</h4><ol><li>设计包含回调函数参数的函数接口</li><li>调用1.中的函数并传递合适的回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, FuncPtr callback)</span> </span>&#123;​<br>    <span class="hljs-comment">// ... 执行一些操作 ...​</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">callback</span>(x, y);​<br>    <span class="hljs-comment">// ... 使用回调函数的返回值进行进一步处理 ...​</span><br>&#125;​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, add);​ <span class="hljs-comment">//可以传递div,multi等等函数，只要函数的参数和返回值与函数指针一致即可</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><!-- ## 指针与内存管理https://lb3fn675fh.feishu.cn/wiki/OVsewICczis2jlkKBgKc3Mz9n8d## 指针与高级数据类型https://lb3fn675fh.feishu.cn/wiki/QlEJwXrH4i9MxPkS1OncaPX4nze## 指针与常量https://lb3fn675fh.feishu.cn/wiki/WcSrwytf5ivjkQkWd86cEJnxnph --><h2 id="void"><a href="#void" class="headerlink" title="void *"></a><code>void *</code></h2><ul><li>任何类型的指针都可以直接赋值给<code>void</code>指针，且无需进行强制类型转换</li><li>而<code>void</code>指针不能直接赋值给其它指针，必须进行显示类型转换</li><li><code>void</code>指针可以和其他指针比较存放的地址是否相同</li><li><code>void</code>指针只有在进行强制类型转换后才可以对其进行正常的指针操作</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>避免野指针：始终确保指针在使用前已经正确初始化，并且在不再需要时将其设置为<code>nullptr</code>。</li><li>避免内存泄漏：动态分配的内存在使用完毕后一定要使用<code>free</code>释放。</li><li>有效性检查：在解引用前检查它是否是<code>nullptr</code>。</li><li>使用智能指针：C++11引入的智能指针可以自动管理内存，减少内存泄露的风险。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
