<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++构造函数</title>
    <link href="/2025/06/12/cpp-constructor/"/>
    <url>/2025/06/12/cpp-constructor/</url>
    
    <content type="html"><![CDATA[<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><ul><li><strong>浅拷贝</strong> <ul><li>就是对变量的简单按位复制内存</li><li>在C++中，默认的拷贝构造函数制作按位复制，也就是浅拷贝</li></ul></li><li><strong>深拷贝</strong> <ul><li>深拷贝除了将所有的成员变量拷贝给新对象外，对于指针等指向外部资源的成员变量，还会为新对象分配一块新的内存，将指针指向的内容也拷贝一份，这样原有对象和新对象的内存都是互相独立的，避免两个对象互相影响和<code>double free</code>的错误。</li><li>在C++中，深拷贝必须由程序员显式地实现</li></ul></li></ul><h3 id="拷贝构造函数和赋值构造函数"><a href="#拷贝构造函数和赋值构造函数" class="headerlink" title="拷贝构造函数和赋值构造函数"></a>拷贝构造函数和赋值构造函数</h3><ul><li>拷贝构造函数<ul><li>是对构造函数的重载，函数原型为 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">myClass</span>(<span class="hljs-type">const</span> myClass &amp; obj)&#123;&#125;<br></code></pre></td></tr></table></figure>注意输入的参数应该是引用，如果不是值传递的话，在值传递时就会触发拷贝构造函数，导致无限递归，造成崩溃。</li><li>会在下面的情况被调用<ul><li>用类的一个对象去初始化另一个对象时(<code>myClass obj2(obj1)</code>和<code>myClass obj3 = obj1</code>两种写法都是)</li><li>当函数的形参是类的对象时（也就是值传递），引用传递不会调用拷贝构造函数</li><li>当函数返回值是类的对象时</li></ul></li></ul></li><li>赋值构造函数<ul><li>是赋值操作符的重载，函数原型为 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">myClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> myClass &amp; obj) &#123;<br>   ...<br>   <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>会在用一个已有对象来给另一个已经创建好的对象赋值时被调用</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;构造函数 \n&quot;</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;析构函数 \n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp; a) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>        <span class="hljs-built_in">memcpy</span>(data, a.data, <span class="hljs-number">100</span>);<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数 \n&quot;</span>;<br>    &#125;<br><br>    A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;a) &#123;<br>            <span class="hljs-keyword">if</span> (!data) &#123;<br>                data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>            &#125;<br>            <span class="hljs-built_in">memcpy</span>(data, a.data, <span class="hljs-number">100</span>);<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;赋值构造函数 \n&quot;</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br><br><span class="hljs-function">A <span class="hljs-title">copyTest</span><span class="hljs-params">(A a)</span> </span>&#123;<span class="hljs-comment">// 这里会调用拷贝构造函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;in copyTest \n&quot;</span>;<br>    <span class="hljs-keyword">return</span> a; <span class="hljs-comment">// 这里也会调用拷贝构造函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a; <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function">A <span class="hljs-title">b</span><span class="hljs-params">(a)</span></span>; <span class="hljs-comment">// 拷贝构造函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== \n&quot;</span>;<br>    A c = b; <span class="hljs-comment">// 拷贝构造函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== \n&quot;</span>;<br>    <span class="hljs-built_in">copyTest</span>(c); <span class="hljs-comment">// 拷贝构造函数</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;=== \n&quot;</span>;<br>    c = a; <span class="hljs-comment">// 赋值构造函数</span><br>&#125;<br><span class="hljs-comment">/* 完整的输出为</span><br><span class="hljs-comment">构造函数 </span><br><span class="hljs-comment">拷贝构造函数 </span><br><span class="hljs-comment">=== </span><br><span class="hljs-comment">拷贝构造函数 </span><br><span class="hljs-comment">=== </span><br><span class="hljs-comment">拷贝构造函数 </span><br><span class="hljs-comment">in copyTest </span><br><span class="hljs-comment">拷贝构造函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">=== </span><br><span class="hljs-comment">赋值构造函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">析构函数 </span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="移动构造函数和移动赋值函数"><a href="#移动构造函数和移动赋值函数" class="headerlink" title="移动构造函数和移动赋值函数"></a>移动构造函数和移动赋值函数</h3><p>与拷贝构造函数和赋值构造函数的区别在于输入的参数为右值引用，且移动构造和移动赋值函数会<strong>直接将资源的所有权转移到当前对象</strong>，省去拷贝的步骤，能够大幅提升效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>() &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">100</span>];<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;构造函数 \n&quot;</span>;<br>    &#125;<br><br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;析构函数 \n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">A</span>(A&amp;&amp; a) &#123;<br>        data = a.data;<span class="hljs-comment">// 直接将资源的所有权转移给当前对象</span><br>        a.data = <span class="hljs-literal">nullptr</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;移动构造函数 \n&quot;</span>;<br>    &#125;<br><br>    A&amp; <span class="hljs-keyword">operator</span>=(A&amp;&amp; a) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;a) &#123;<br>            data = a.data; <span class="hljs-comment">// 直接将资源的所有权转移给当前对象</span><br>            a.data = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;移动赋值函数 \n&quot;</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span>* data&#123;<span class="hljs-literal">nullptr</span>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>     A a; <span class="hljs-comment">// 构造函数</span><br>     A d; <span class="hljs-comment">// 构造函数</span><br>     <span class="hljs-function">A <span class="hljs-title">b</span><span class="hljs-params">(std::move(a))</span></span>; <span class="hljs-comment">// 移动构造函数</span><br>     std::cout &lt;&lt; <span class="hljs-string">&quot;=== \n&quot;</span>;<br>     A c = std::<span class="hljs-built_in">move</span>(b); <span class="hljs-comment">// 移动构造函数</span><br>     std::cout &lt;&lt; <span class="hljs-string">&quot;--- \n&quot;</span>;<br>     c = std::<span class="hljs-built_in">move</span>(d); <span class="hljs-comment">// 移动赋值函数</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="delete-explicit和default"><a href="#delete-explicit和default" class="headerlink" title="delete,explicit和default"></a><code>delete</code>,<code>explicit</code>和<code>default</code></h3><ul><li><code>delet</code>是C++11引入的新特性，在成员函数后面使用<code>=delete</code>修饰，表示禁用该函数。智能指针<code>unique_ptr</code>就是通过禁用拷贝构造函数来实现的。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">A&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp; a) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure></li><li><code>explicit</code>则在函数前面修饰，用于禁止隐式类型转换<ul><li>在 C++ 中，任何只有一个参数（或者除了第一个参数外，其它参数都有默认值）的构造函数，默认就是一个<strong>转换构造函数</strong>（converting constructor），它允许编译器在需要的时候把那个参数类型 <strong>隐式</strong> 地转换成该类的对象，例如<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a) &#123; a_ = a; &#125;<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">A <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    A b = <span class="hljs-number">100</span>; <span class="hljs-comment">// 会触发隐式类型转换</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>但这样的隐式有时候并不是我们所期望的，可能只是代码写错了，为了避免这种情况，可以用<code>explicit</code>修饰构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123; a_ = a; &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li>除了构造函数外，<code>explicit</code>还可以用于修饰类型转换函数（C++11）<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">bool</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> some_flag; &#125;<br>&#125;;<br><br>B b;<br><span class="hljs-keyword">if</span> (b) &#123;      <span class="hljs-comment">// 错误：operator bool() 是 explicit 的，不能隐式转换</span><br>&#125;<br><span class="hljs-type">bool</span> x = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">bool</span>&gt;(b);  <span class="hljs-comment">// OK：显式转换</span><br><br></code></pre></td></tr></table></figure></li></ul></li><li><code>default</code>一般用于修饰构造函数，要求编译器生成默认的构造函数。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a) &#123; a_ = a; &#125;​<br>    ~<span class="hljs-built_in">A</span>() &#123;&#125;​<br>    ​<br><span class="hljs-keyword">private</span>:​<br>    <span class="hljs-type">int</span> a_;​<br>&#125;;​<br>​<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A a;<br>&#125;<br></code></pre></td></tr></table></figure>  上面的代码会由于<code>A</code>没有无参数的构造函数而导致报错，可以在<code>A</code>中添加  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">A</span>() = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure>  解决，但是默认的构造函数并不会将<code>a_</code>初始化。<br>  此外<code>default</code>也可以修饰拷贝构造函数。</li></ul><!-- ### 自赋值问题的解决C++允许一个变量有多个别名（指针和引用），因此可能会导致自赋值的问题<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)&#123;<br>    <span class="hljs-keyword">delete</span> pb;                   <span class="hljs-comment">// stop using current bitmap</span><br>    pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);    <span class="hljs-comment">// start using a copy of rhs&#x27;s bitmap</span><br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                <span class="hljs-comment">// see Item 10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>例如上面的代码，当<code>rhs == *this</code>时，<code>delete pb</code>使得<code>rhs.pb</code>成为空值，接下来<code>new</code>的数据便是空的。自赋值问题的解决有三种方法</p><ol><li>检查传入的参数是否是<code>*this</code><br>这个方法是最直接也是组容易想到的，但却不是<strong>异常安全</strong>的 –&gt;</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/myrosy/p/17377409.html">[cnblog.com] C++ 深拷贝、浅拷贝及拷贝构造函数</a></li></ul><!-- * [Effective C++ 11：赋值运算符的自赋值问题](https://harttle.land/2015/07/30/effective-cpp-11.html)  -->]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的值类型</title>
    <link href="/2025/06/11/cpp-lrval/"/>
    <url>/2025/06/11/cpp-lrval/</url>
    
    <content type="html"><![CDATA[<!-- ## 基本定义 --><p>C++中表达式的结果有两个属性：类型和值类别（value categories），类型影响值的表示范围和所占的存储空间，值类别则影响</p><ul><li>能否取地址和修改</li><li>引用的绑定规则</li><li>生命周期</li></ul><p>等特性。分为以下几类</p><h4 id="1-左值-lvalue"><a href="#1-左值-lvalue" class="headerlink" title="1. 左值 lvalue"></a>1. 左值 <code>lvalue</code></h4><p>具有存储位置的对象，可以被修改和获取，且在<strong>表达式结束后依然存在</strong>。简单地说，<strong>能够用<code>&amp;</code>取地址的就是左值</strong>。包括</p><ul><li>函数名<br>当我们将一个函数名作为值来使用时，它会自动转换成指向对应函数的指针</li><li>具名的变量 例如<code>std::cin</code>,<code>std::endl</code></li><li>返回左值引用的函数调用</li><li>前置自增&#x2F;自减运算符的表达式 例如<code>++i</code>,<code>--i</code></li><li>由赋值运算符或复合赋值运算符连接的表达式 例如<code>a=b</code>、<code>a+=b</code>、<code>a%=b</code></li><li>解引用表达式</li><li>字符串字面值 例如<code>&quot;abac&quot;</code></li></ul><h4 id="2-纯右值-prvalue"><a href="#2-纯右值-prvalue" class="headerlink" title="2. 纯右值 prvalue"></a>2. 纯右值 <code>prvalue</code></h4><p>不与对象的存储位置直接关联，无法获取地址且没有标识符（也就是不具名）的临时对象，包括</p><ul><li>除了字符串字面量以外的字面量 例如3，<code>false</code></li><li>返回非引用类型的函数调用</li><li>后置自增&#x2F;自减运算符的表达式 例如<code>i++</code>,<code>i--</code></li><li>算术表达式 <code>a+b</code>,<code>a&amp;b</code></li><li>逻辑表达 <code>a&amp;&amp;b</code>,<code>a||n</code>,<code>~a</code></li><li>比较表达式 <code>a==b</code></li><li>取址表达式 <code>&amp;a</code> 等</li></ul><h4 id="3-将亡值-xvalue"><a href="#3-将亡值-xvalue" class="headerlink" title="3. 将亡值 xvalue"></a>3. 将亡值 <code>xvalue</code></h4><p>在C++11之前的右值和C++11后的纯右值是等价的。C++11中的将亡值是随着右值引用<code>T&amp;&amp;</code>的引入而引入的。将亡值表达式就是下列表达式：</p><ul><li>返回右值引用的函数的调用表达式</li><li>转换为右值引用的转换函数的调用表达式</li></ul><p>之所以要引入右值引用和将亡值，是因为在C++中，当我们使用一个<strong>左值</strong>去初始化一个新对象或者给已有的对象赋值时，会调用<strong>拷贝构造函数</strong>或<strong>赋值运算符</strong>来拷贝资源。在C++11中，引入了<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，当用<strong>右值</strong>来来初始化或赋值的话，这两个函数来实现，从而避免拷贝，提高效率。这个右值完成为左值初始化或赋值的任务后，它的资源已经被移动给了这个左值，其本身马上就会被析构。也就说，这个右值在被定义时，它就是“将亡”的了。</p><h4 id="4-广义左值和右值"><a href="#4-广义左值和右值" class="headerlink" title="4. 广义左值和右值"></a>4. 广义左值和右值</h4><p>广义左值包含左值和将亡值，右值包含纯右值和将亡值。</p><h4 id="值类型的辨析"><a href="#值类型的辨析" class="headerlink" title="值类型的辨析"></a>值类型的辨析</h4><h5 id="1-字符串字面量是左值"><a href="#1-字符串字面量是左值" class="headerlink" title="1. 字符串字面量是左值"></a>1. 字符串字面量是左值</h5><p>字符串字面值是所有字面值中唯一的左值，而其他的字面值都是右值，这是因为早期间C++将字符串字面值实现为<code>char</code>类型的数组，为每个字符都分配了空间并允许进行操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">cout&lt;&lt;&amp;(<span class="hljs-string">&quot;abc&quot;</span>)&lt;&lt;endl;<br><span class="hljs-type">char</span> *p_char=<span class="hljs-string">&quot;abc&quot;</span>;<span class="hljs-comment">//注意不是char *p_char=&amp;(&quot;abc&quot;);</span><br></code></pre></td></tr></table></figure><p>例如上面的代码，字符串字面量<code>&quot;abc&quot;</code>可以直接用来取地址和给指针赋值，<code>p_char</code>的值就是字符串首字母<code>&#39;a&#39;</code>的地址</p><h5 id="2-具名的右值引用是左值，不具名的右值引用是右值"><a href="#2-具名的右值引用是左值，不具名的右值引用是右值" class="headerlink" title="2. 具名的右值引用是左值，不具名的右值引用是右值"></a>2. 具名的右值引用是左值，不具名的右值引用是右值</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-comment">// 两个重载，用于区分传入的是左值还是右值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Called identify(int&amp;): lvalue\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Called identify(int&amp;&amp;): rvalue\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 1. 普通左值</span><br>    <span class="hljs-built_in">identify</span>(a);            <span class="hljs-comment">// 匹配 int&amp;  —— 输出 lvalue</span><br><br>    <span class="hljs-comment">// 2. 字面右值</span><br>    <span class="hljs-built_in">identify</span>(<span class="hljs-number">20</span>);           <span class="hljs-comment">// 匹配 int&amp;&amp; —— 输出 rvalue</span><br><br>    <span class="hljs-comment">// 3. 具名的右值引用</span><br>    <span class="hljs-type">int</span>&amp;&amp; r = <span class="hljs-number">30</span>;           <span class="hljs-comment">// r 的类型是 int&amp;&amp;，但它有名字</span><br>    <span class="hljs-built_in">identify</span>(r);            <span class="hljs-comment">// r 是一个有名字的表达式，所以被当作左值 —— 输出 lvalue</span><br><br>    <span class="hljs-comment">// 如果想把 r 当作右值，需要 std::move（或 static_cast&lt;int&amp;&amp;&gt;）</span><br>    <span class="hljs-built_in">identify</span>(std::<span class="hljs-built_in">move</span>(r)); <span class="hljs-comment">// 输出 rvalue</span><br><br>    <span class="hljs-comment">// 4. 不具名的右值引用（临时对象）</span><br>    <span class="hljs-built_in">identify</span>(<span class="hljs-type">int</span>&amp;&amp;(<span class="hljs-number">40</span>));    <span class="hljs-comment">// 直接构造的临时右值 —— 输出 rvalue</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-i和i"><a href="#3-i和i" class="headerlink" title="3. ++i和i++"></a>3. <code>++i</code>和<code>i++</code></h5><ul><li><code>++i</code>是先把<code>i</code>加1再赋值给<code>i</code>，表达式返回的值就是<code>i</code>，因此它的结果是具名的，<code>i</code>在表达式结束后依然存在，因此<code>++i</code>是左值</li><li><code>i++</code>则是先对<code>i</code>进行拷贝，将拷贝的副本返回后再对<code>i</code>加1，由于返回的结果是<code>i</code>的拷贝，因此是不具名的，是纯右值</li></ul><h4 id="左值与右值的转换"><a href="#左值与右值的转换" class="headerlink" title="左值与右值的转换"></a>左值与右值的转换</h4><p>可以使用<code>std::move</code>将左值转换成右值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-comment">// 两个重载，用于区分传入的是左值还是右值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Called identify(int&amp;): lvalue\n&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identify</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp;&amp; x)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Called identify(int&amp;&amp;): rvalue\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// 如果想把 r 当作右值，需要 std::move（或 static_cast&lt;int&amp;&amp;&gt;）</span><br>    <span class="hljs-built_in">identify</span>(std::<span class="hljs-built_in">move</span>(r)); <span class="hljs-comment">// 输出 rvalue</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="万能引用"><a href="#万能引用" class="headerlink" title="万能引用"></a>万能引用</h4><p>当</p><ul><li><code>T</code>是一个模板参数，且需要进行类型推导，或者</li><li>使用<code>auto &amp;&amp;</code>声明变量</li></ul><p>时，<code>T&amp;&amp;</code>或<code>auto &amp;&amp;</code>既可以绑定到左值也可以绑定到右值，称之为<strong>万能引用</strong>。</p><p>为了达成<code>T&amp;&amp;</code>或<code>auto &amp;&amp;</code>的上述功能，C++规定，当应用的引用出现时，会通过引用折叠简化为单一引用</p><ul><li><code>&amp; &amp;</code>    → <code>&amp;</code></li><li><code>&amp; &amp;&amp;</code>   → <code>&amp;</code></li><li><code>&amp;&amp; &amp;</code>   → <code>&amp;</code></li><li><code>&amp;&amp; &amp;&amp;</code>  → <code>&amp;&amp;</code></li></ul><p>例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T&amp;&amp; arg)</span> </span>&#123; ​<br>    <span class="hljs-comment">// arg 是万能引用，可以绑定到左值或右值​</span><br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;​<br>    <span class="hljs-built_in">foo</span>(a);       <span class="hljs-comment">// T 推导为 int&amp; → arg 类型是 int&amp;（左值引用）​可以这样理解：为了让T&amp;&amp;折叠为int &amp;&amp;，所以推导T为int​</span><br>    <span class="hljs-built_in">foo</span>(<span class="hljs-number">10</span>);      <span class="hljs-comment">// T 推导为 int  → arg 类型是 int&amp;&amp;（右值引用）​</span><br>&#125;​<br></code></pre></td></tr></table></figure><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>通过<code>std::forward&lt;&gt;</code>模板，我们能够实现<strong>完美转发</strong>，即在参数传递时<strong>保留其原始的值类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br>​<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T &amp;&amp;t)</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    std::cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-string">&quot;rvalue\n&quot;</span>;​<br>&#125;​<br>​<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(T &amp;t)</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    std::cout &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-string">&quot;lvalue\n&quot;</span>;​<br>&#125;​<br>​<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper</span><span class="hljs-params">(T &amp;&amp;t)</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    <span class="hljs-built_in">process</span>(std::forward&lt;T&gt;(t));​<br>&#125;​<br>​<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wrapper_common</span><span class="hljs-params">(T &amp;&amp;t)</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    <span class="hljs-built_in">process</span>(t);​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>​</span><br><span class="hljs-function"></span>&#123;​<br>    <span class="hljs-comment">// 测试右值引用​</span><br>    <span class="hljs-built_in">wrapper</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// rvalue​ </span><br>    <span class="hljs-comment">// 测试左值引用​</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;​<br>    <span class="hljs-built_in">wrapper</span>(i); <span class="hljs-comment">// lvalue​ 两个process模板都可以时，编译器会选择更加specialized那个</span><br>​<br>    <span class="hljs-comment">// 测试完美转发将亡值​</span><br>    <span class="hljs-built_in">wrapper</span>(std::<span class="hljs-built_in">move</span>(i)); <span class="hljs-comment">// rvalue​</span><br>​<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">2</span>;​<br>    <span class="hljs-comment">// 测试不用完美转发​</span><br>    <span class="hljs-built_in">wrapper_common</span>(std::<span class="hljs-built_in">move</span>(j)); <span class="hljs-comment">// lvalue​</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>万能引用是参数绑定的入口，负责接收任意的值类别。​</li><li>而<code>std::forward</code>是转发的出口，负责恢复原始值的类别。以上面的代码为例，<code>wrapper</code>中的<code>t</code>无论接受的是左值还是右值，在<code>wrapper</code>内部都是左值，因为它是<strong>具名</strong>的，且在栈上分配了空间。而<code>std::forward&lt;T&gt;(t)</code>则能根据<code>T</code>是<code>int</code>(<code>t</code>传入的是右值)还是<code>int &amp;</code>（<code>t</code>传入的是左值）来将<code>t</code>恢复成它原来的值类型。</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.cnblogs.com/zpcdbky/p/5275959.html">[cnblog] 话说C++中的左值、纯右值、将亡值</a></li><li><a href="https://theonegis.github.io/cxx/C-%E4%B8%AD%E7%9A%84%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%E5%92%8C%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/">C++中的万能引用和完美转发</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的异常处理</title>
    <link href="/2025/06/10/cpp-exception/"/>
    <url>/2025/06/10/cpp-exception/</url>
    
    <content type="html"><![CDATA[<h2 id="异常处理的基本操作"><a href="#异常处理的基本操作" class="headerlink" title="异常处理的基本操作"></a>异常处理的基本操作</h2><p>C++中通过下面的三个关键字来是实现异常处理</p><ul><li><code>try</code><br>用于标记可能出现异常的代码块，被<code>try</code>标记的代码块称为保护代码</li><li><code>throw</code><br>当在保护代码中遇到异常时，可以通过<code>throw</code>关键字来将异常抛出</li><li><code>catch</code><br>跟在保护代码后面,<code>catch</code>关键字能够捕获<code>throw</code>抛出的异常，并根据异常的类型进行不同的处理</li></ul><p><strong>示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">division</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>( b == <span class="hljs-number">0</span> )<br>   &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Division by zero condition!&quot;</span>; <span class="hljs-comment">//throw抛出了const char*类型的异常</span><br>   &#125;<br>   <span class="hljs-keyword">return</span> (a/b);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> x = <span class="hljs-number">50</span>;<br>   <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">double</span> z = <span class="hljs-number">0</span>;<br> <br>   <span class="hljs-keyword">try</span> &#123;<br>     z = <span class="hljs-built_in">division</span>(x, y);<br>     cout &lt;&lt; z &lt;&lt; endl;<br>   &#125;<span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg) &#123; <span class="hljs-comment">//catch捕获throw抛出的异常</span><br>     cerr &lt;&lt; msg &lt;&lt; endl; <span class="hljs-comment">//对异常进行处理</span><br>   &#125;<br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="C-异常类"><a href="#C-异常类" class="headerlink" title="C++异常类"></a>C++异常类</h2><p><code>throw</code>和<code>catch</code>既可以抛出和捕获基础类型的异常，也可以使用C++预定义的异常类，这些异常类有统一的的接口，便于我们进行异常的捕获和处理。</p><p>C++预定义的异常类包括：</p><ul><li><code>std::exception</code>：所有标准异常的基类。​<ul><li><code>std::bad_alloc</code>：内存分配失败时抛出。​</li><li><code>std::bad_cast</code>：动态类型转换失败时抛出。​</li><li><code>std::bad_typeid</code>：使用typeid运算符失败时抛出。​</li><li><code>std::bad_exception</code>：在函数声明中使用了异常规格，但抛出了未列出的异常时抛出（C++11已弃用）。​</li><li><code>std::logic_error</code>：逻辑错误异常基类，包括：​<ul><li><code>std::domain_error</code>：数学域错误，如sqrt(-1)。​</li><li><code>std::invalid_argument</code>：无效参数错误。​</li><li><code>std::length_error</code>：超出允许长度的错误。​</li><li><code>std::out_of_range</code>：范围错误，如访问vector的非法索引。​</li></ul></li><li><code>std::runtime_error</code>：运行时错误异常基类，包括：​<ul><li><code>std::overflow_error</code>：上溢错误。​</li><li><code>std::range_error</code>：范围错误（与std::out_of_range不同，用于其他情况）。​</li><li><code>std::underflow_error</code>：下溢错误。​<br>上面的异常类最常使用的核心接口<code>.what()</code>，返回<code>const char *</code>，用于说明异常的情况。</li></ul></li></ul></li></ul><p><strong>标准异常类的示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testLogicError</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid argument error!&quot;</span>);​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testRuntimeError</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Out of range error!&quot;</span>);​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">try</span> &#123;​<br>        <span class="hljs-built_in">testLogicError</span>(); <span class="hljs-comment">// 抛出逻辑错误异常​</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> logic_error&amp; e) &#123;​<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught a logic_error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;​<br>    &#125;​<br>​<br>    <span class="hljs-keyword">try</span> &#123;​<br>        <span class="hljs-built_in">testRuntimeError</span>(); <span class="hljs-comment">// 抛出运行时错误异常​</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> runtime_error&amp; e) &#123;​<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught a runtime_error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;​<br>    &#125;​<br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><p>此外，还可以通过继承<code>std::exception</code>并重载<code>what</code>来实现自定义的异常类。</p><p><strong>自定义异常类的示例</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br>​<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyException</span> : <span class="hljs-keyword">public</span> exception &#123;​<br><span class="hljs-keyword">public</span>:​<br>    <span class="hljs-built_in">MyException</span>(<span class="hljs-type">const</span> string&amp; message) : <span class="hljs-built_in">message_</span>(message) &#123;&#125;​<br>​<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> <span class="hljs-keyword">override</span> </span>&#123;​<br>        <span class="hljs-keyword">return</span> message_.<span class="hljs-built_in">c_str</span>();​<br>    &#125;​<br>​<br><span class="hljs-keyword">private</span>:​<br>    string message_;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testCustomException</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyException</span>(<span class="hljs-string">&quot;Custom exception occurred!&quot;</span>);​<br>&#125;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-keyword">try</span> &#123;​<br>        <span class="hljs-built_in">testCustomException</span>(); <br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> MyException&amp; e) &#123;​<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught a MyException: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;​<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> exception&amp; e) &#123;​<br>        cout &lt;&lt; <span class="hljs-string">&quot;Caught an unknown exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;​<br>    &#125;​<br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><h2 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a><code>noexcept</code></h2><p>从C++11开始，可以使用<code>noexcept</code>修饰函数，声明函数不会抛出任何异常，这有利于编译器做更多的优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>; <span class="hljs-comment">// 声明函数不抛出任何异常​</span><br></code></pre></td></tr></table></figure><p>此外，<code>noexcept</code>还可以作为运算符，传入函数来验证某个函数是否被<code>noexcept</code>修饰</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">may_throw</span><span class="hljs-params">()</span></span>;​<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">no_throw</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>  <span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">may_throw</span>()); <span class="hljs-comment">// false​</span><br>  <span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">no_throw</span>()); <span class="hljs-comment">// true​</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类的析构函数默认是<code>noexcept</code>的</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的引用</title>
    <link href="/2025/06/09/cpp-reference/"/>
    <url>/2025/06/09/cpp-reference/</url>
    
    <content type="html"><![CDATA[<p>引用是一种特殊的变量别名机制，它</p><ul><li>是变量的别名，既不是变量本身，也不是变量的拷贝。</li><li>在定义时必须被初始化，且一旦被绑定到一个变量上，就不能再被绑定到另一个变量上，与指针相比更加安全（但也并非完全安全，引用也依赖于绑定对象的有效性，如果绑定的对象内存被释放，则引用的行为是未定义的）。</li><li>必须被绑定到有效的对象，不能为<code>nullptr</code>，这就可以天然地避免空指针的问题。</li><li>操作简单。</li></ul><h2 id="引用的作用"><a href="#引用的作用" class="headerlink" title="引用的作用"></a>引用的作用</h2><ul><li>作为别名<br>  可以简化复杂数据的访问  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span>&#123;<br>    std::string name;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; grades;<br>&#125;<br>Person guts&#123;<span class="hljs-string">&quot;Guts&quot;</span>,&#123;<span class="hljs-number">80</span>,<span class="hljs-number">99</span>,<span class="hljs-number">59</span>&#125;&#125;;<br>std::string &amp; english_grade = guts.grades[<span class="hljs-number">2</span>];<br>english_grade++;<br></code></pre></td></tr></table></figure></li><li>作为参数传递<ul><li>避免拷贝开销</li><li>允许修改实参</li><li><code>const</code>引用作为参数也是有意义的，可以避免拷贝开销，并且<code>const</code>引用还可以绑定右值</li></ul></li><li>作为函数返回值<ul><li>可以用于链式调用，函数返回引用，引用又调用函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> MyClass&amp; obj) &#123;​<br>    os &lt;&lt; obj.<span class="hljs-built_in">data</span>();​<br>    <span class="hljs-keyword">return</span> os;  <span class="hljs-comment">// 允许链式调用</span><br>&#125;<br>std::cout &lt;&lt; obj1 &lt;&lt; obj2;<span class="hljs-comment">//等价于std::cout &lt;&lt; obj1.data() &lt;&lt; obj2.data();</span><br></code></pre></td></tr></table></figure></li><li>用于实现运算符的重载<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">MyClass&amp; MyClass::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;​<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;​<br>        <span class="hljs-comment">// 赋值操作​</span><br>    &#125;​<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 返回当前对象的引用​</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>右值引用<br>右值引用<code>T&amp;&amp;</code>可以绑定右值(<code>const</code>引用也可以)，通常用于移动语义，避免深拷贝。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>&amp;&amp; x = <span class="hljs-number">42</span>;     <span class="hljs-comment">// 合法，右值引用绑定字面量（右值）</span><br><span class="hljs-type">int</span>&amp; y = <span class="hljs-number">42</span>;      <span class="hljs-comment">// 错误，左值引用不能绑定右值</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; z = <span class="hljs-number">42</span>;<span class="hljs-comment">// 合法，const引用也可以绑定右值</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span> &#123;​<br><span class="hljs-keyword">public</span>:​<br>    <span class="hljs-built_in">MyString</span>(MyString&amp;&amp; other) <span class="hljs-keyword">noexcept</span> ​<br>        : <span class="hljs-built_in">data_</span>(other.data_), <span class="hljs-built_in">size_</span>(other.size_) &#123;​<br>        other.data_ = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 转移资源所有权​</span><br>    &#125;​<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><code>const</code>引用<br><code>const</code>引用也可以绑定右值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(string&amp; a)</span> </span>&#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; a)</span> </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func1</span>(<span class="hljs-string">&quot;12323&quot;</span>);<span class="hljs-comment">//变异失败，因为string &amp;作为一个引用类型，必须要知道它绑定对象的地址才行，而输入值是const char*类型的右值</span><br>    <span class="hljs-built_in">func2</span>(<span class="hljs-string">&quot;12323&quot;</span>);<br>&#125; <br><br></code></pre></td></tr></table></figure></li></ul><h3 id="与指针的区别"><a href="#与指针的区别" class="headerlink" title="与指针的区别"></a>与指针的区别</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;​<br>    <span class="hljs-comment">//代码段1</span><br>    <span class="hljs-type">int</span>&amp; ref = x;  <span class="hljs-comment">// 编译器等价处理为 int* const ref = &amp;x;​</span><br>    ref = <span class="hljs-number">20</span>;      <span class="hljs-comment">// 等价于 *ref = 20;​</span><br>    ​<span class="hljs-comment">//代码段2</span><br>    <span class="hljs-type">int</span>* ptr = &amp;x;​<br>    *ptr = <span class="hljs-number">30</span>;​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><p>代码段1和代码段2在生成的汇编代码中除了数字外完全一样，因为引用本质上是通过指针常量来实现的。</p><table><thead><tr><th align="left">特性</th><th align="left">引用</th><th align="left">指针</th></tr></thead><tbody><tr><td align="left">初始化要求</td><td align="left">必须初始化，且不可重新绑定到其他对象</td><td align="left">可以声明为空指针（<code>nullptr</code>），后续可修改指向</td></tr><tr><td align="left">空值合法性</td><td align="left">不允许空引用</td><td align="left">允许空指针（<code>nullptr</code>）</td></tr><tr><td align="left">内存占用</td><td align="left">不占用显式内存（编译器优化）</td><td align="left">占用独立内存（存储地址值）</td></tr><tr><td align="left">操作语法</td><td align="left">直接使用对象语法（无<code>＊</code>或 <code>-&gt;</code> ）</td><td align="left">需用<code>＊</code>解引用或 <code>-&gt;</code> 访问成员</td></tr><tr><td align="left">类型安全性</td><td align="left">强类型绑定，无类型转换风险</td><td align="left">允许 <code>void＊</code>和危险的类型转换</td></tr><tr><td align="left">多级间接访问</td><td align="left">仅支持单层引用（无引用的引用）</td><td align="left">支持多级指针（<code>int＊＊</code>）</td></tr><tr><td align="left">内存地址可见性</td><td align="left">无法直接获取引用的地址（<code>＆ref</code> 返回原对象地址）</td><td align="left">可直接获取指针变量的地址（<code>＆ptr</code>）</td></tr></tbody></table><ol><li>当需要指向空值或重新指向另一个对象时，使用指针。</li><li>当需要在函数间安全地传递大型对象或需要修改函数参数时，优先考虑引用（除非有指向空或重新指向的需求）。</li><li>在需要动态内存分配或管理内存时，使用指针。</li><li>在需要避免拷贝大型对象以提高效率时，使用引用（特别是作为函数参数或返回值）。</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的enum class</title>
    <link href="/2025/06/08/cpp-enum-class/"/>
    <url>/2025/06/08/cpp-enum-class/</url>
    
    <content type="html"><![CDATA[<h2 id="与enum的对比"><a href="#与enum的对比" class="headerlink" title="与enum的对比"></a>与<code>enum</code>的对比</h2><p>C++11之所以要引入<code>enum class</code>，是因为传统的<code>enum</code></p><ul><li>作用域不限范围，会造成命名空间的污染  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;black,white,red&#125;;<span class="hljs-comment">//black、white、red作用域和color作用域相同</span><br><br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>;<span class="hljs-comment">//错误，white已经被声明过了</span><br></code></pre></td></tr></table></figure>  而<code>enum class</code>的枚举成员默认具有强作用域，需要通过枚举类型名来访问，能够降低命名空间的污染  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span>&#123;black,white,red&#125;; <span class="hljs-comment">//black、white、red作用域仅在大括号内生效</span><br><br><span class="hljs-keyword">auto</span> white = <span class="hljs-literal">false</span>;<span class="hljs-comment">//正确，这个white并不是Color中的white</span><br><br>Color c = white;<span class="hljs-comment">//错误，在作用域范围内没有white这个枚举量</span><br><br>Color c = Color::white;<span class="hljs-comment">//正确</span><br><br><span class="hljs-keyword">auto</span> c = Color::white;<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li>会发生隐式类型转换  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;black,white,red&#125;;<br><span class="hljs-function">std::vector&lt;std::<span class="hljs-type">size_t</span>&gt; <span class="hljs-title">primeFactors</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> x)</span></span>;<span class="hljs-comment">//函数返回x的质因数</span><br><br>Color c = red;<br><br><span class="hljs-keyword">if</span>(c &lt; <span class="hljs-number">14.5</span>)<span class="hljs-comment">//将color型别和double型别比较，发生隐式转换</span><br>&#123;<br>    <span class="hljs-keyword">auto</span> factors = <span class="hljs-built_in">primeFactors</span>(c);  <span class="hljs-comment">//计算一个color型别的质因数，发生隐式转换</span><br>&#125;<br></code></pre></td></tr></table></figure>  而<code>enum class</code>的元素只能通过<code>static_cast</code>进行强制类型转换</li><li>不能进行前置声明，而<code>enum class</code>可以  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>;<span class="hljs-comment">//错误</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span>;<span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/weixin_42817477/article/details/109029172">[CSDN]C++11枚举类——enum class</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的const关键字</title>
    <link href="/2025/06/08/cpp-const/"/>
    <url>/2025/06/08/cpp-const/</url>
    
    <content type="html"><![CDATA[<h2 id="const关键字的使用"><a href="#const关键字的使用" class="headerlink" title="const关键字的使用"></a><code>const</code>关键字的使用</h2><p><code>const</code>关键字可以修饰C++的内置变量、指针、自定义对象、成员函数、返回值和函数参数，以告诉编译器某些值需要保持不变的。也就是说，<code>const</code>关键字是在编译过程中发挥作用的。</p><h3 id="const修饰普通类型的变量"><a href="#const修饰普通类型的变量" class="headerlink" title="const修饰普通类型的变量"></a><code>const</code>修饰普通类型的变量</h3><p>当一个变量被<code>const</code>修饰时，程序不能改变这个变量的值</p><h3 id="const修饰指针变量"><a href="#const修饰指针变量" class="headerlink" title="const修饰指针变量"></a><code>const</code>修饰指针变量</h3><p><code>const</code>修饰指针变量时，情况会变复杂，有三种情况</p><ol><li><code>const</code>修饰指针指向的内容<br>此时该指针指向的内容是不可修改的，更准确的说，是<strong>不能通过这个指针来修改它指向的内容</strong> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p = &amp;a;<br><span class="hljs-type">int</span> <span class="hljs-type">const</span> * p = &amp;a;<span class="hljs-comment">//两种写法等价</span><br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">//错误的</span><br>a = <span class="hljs-number">9</span>;<span class="hljs-comment">//正确的</span><br></code></pre></td></tr></table></figure></li><li><code>const</code>修饰指针<br>即指针常量，指针不能修改 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = &amp;a;<br>*p = <span class="hljs-number">9</span>; <span class="hljs-comment">// 正确</span><br><span class="hljs-type">int</span>  b = <span class="hljs-number">7</span>;<br>p = &amp;b; <span class="hljs-comment">// 错误</span><br></code></pre></td></tr></table></figure></li><li><code>const</code>修饰指针和指针指向的内容<br>则既不能通过指针修改指向的内容，也不能修改指针本身 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span>  p = &amp;a;<br></code></pre></td></tr></table></figure>为了更好地理解上述的三种情况为什么这样声明，推荐阅读<a href="https://cseweb.ucsd.edu/~gbournou/CSE131/rt_lt.rule.html">C Right-Left Rule (Rick Ord’s CSE 131</a></li></ol><h3 id="const修饰函数参数和返回值"><a href="#const修饰函数参数和返回值" class="headerlink" title="const修饰函数参数和返回值"></a><code>const</code>修饰函数参数和返回值</h3><p><code>const</code>修饰函数参数时，参数在函数体内无法被修改。最常见的情况是用<code>const</code>修饰指针防止其被意外篡改，以及<code>const</code>+引用传递以免去自定义类型在值传递时构造临时对象的开销。</p><!-- 要理清`const`修饰函数返回值对返回值的影响，首先要明白在C/C++中，函数的返回值总是**按值**返回的，函数会把返回值复制到一个外部的临时变量`a`，这个变量时可以被拷贝的。如果有在函数被调用后，有外部变量`b`能够“接住”`a`，那么`a`会被拷贝到`b`（对于自定义的变量，则会调用赋值构造函数），然后将`a`释放，如果没有变量“接住”`a`，则直接释放。接下来我们分析`const`修饰函数返回值时，三种不同的情况 --><p><code>const</code>修饰函数返回值时，有下面三种不同的情况</p><ol><li>修饰内置类型的返回值<br>返回的是一个临时变量，<code>const</code>修饰没有实际意义，与不修饰时一样</li><li>修饰自定义类型的返回值<br>则返回值不能作为左值使用，既不能被赋值也不能被修改.同时也不能调用返回对象的非<code>const</code>成员函数</li><li>修饰指针或引用类型的返回值<ul><li>函数返回指向常量的指针   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * p =<span class="hljs-built_in">func</span>();<br>*p = <span class="hljs-number">10</span>;       <span class="hljs-comment">// 错误</span><br>p++; <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li>函数返回指针常量  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = <span class="hljs-built_in">func</span>();<br>*p = <span class="hljs-number">10</span>;       <span class="hljs-comment">//正确</span><br>p++;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li>函数返回指向常量的指针常量  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-type">const</span> p = <span class="hljs-built_in">func</span>();<br>*p = <span class="hljs-number">10</span>;       <span class="hljs-comment">//错误</span><br>p++;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><code>const</code>修饰引用返回值<br> 返回一个只读的引用  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">const</span> MyClass&amp; <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> MyClass&amp; ref = <span class="hljs-built_in">func</span>();<br>ref.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="const修饰类的成员函数"><a href="#const修饰类的成员函数" class="headerlink" title="const修饰类的成员函数"></a><code>const</code>修饰类的成员函数</h3><p>在成员函数的标识符后面修饰，保证在调用过程中不会修改对象中任何没有<code>mutable</code>修饰的成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Test</span>()&#123;&#125;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> _m):_cm(_m)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_cm</span><span class="hljs-params">()</span><span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>       <span class="hljs-keyword">return</span> _cm;<br>    &#125;<br> <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _cm;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：<code>const</code>关键字不能与<code>static</code>关键字同时使用，因为<code>static</code>关键字修饰静态成员函数，静态成员函数不含有<code>this</code>指针，即不能实例化，<code>const</code>成员函数必须具体到某一实例。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a><code>volatile</code>关键字</h2><p><code>volatile</code>修饰的变量表示其可以被某些编译器未知的因素修改。例如</p><ul><li>操作系统</li><li>硬件</li><li>其他的线程<br>这样编译器就不会对<code>volatile</code>修饰的变量进行优化。例如</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> i=<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a = i;<br>...<br><span class="hljs-comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span><br><span class="hljs-type">int</span> b = i;<br></code></pre></td></tr></table></figure><p>在上面的代码中，无论是将<code>i</code>赋值给<code>a</code>还是<code>b</code>，都要从<code>i</code>的地址中读取值，而如果<code>i</code>没有被<code>volatile</code>修饰，那么编译器就会优化对<code>b</code>的赋值，直接将上次从<code>i</code>的地址中读取的值赋值给<code>b</code>,而不是重新读取<code>i</code>的地址中的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>上面的代码也是合法的，·且<code>const</code>和<code>volatile</code>关键字都能发挥作用</p><ul><li>在<code>a</code>的作用域内，无法对<code>a</code>进行修改，因为它是<code>const</code>修饰的</li><li>但是<code>a</code>的值可能被其他线程或者别的外部事件改变，因为它是<code>volatile</code>修饰的</li></ul><h2 id="mutable关键字"><a href="#mutable关键字" class="headerlink" title="mutable关键字"></a><code>mutable</code>关键字</h2><p><code>mutable</code>关键字用于修饰类的成员变量。</p><ul><li>当成员变量被<code>mutable</code>修饰时，表示该变量时可变的，即使包含它的对象被声明为<code>const</code>类型</li><li><code>mutable</code>修饰成员变量不会影响其在类外部的可见状态</li></ul><h2 id="const与-define的区别"><a href="#const与-define的区别" class="headerlink" title="const与#define的区别"></a><code>const</code>与<code>#define</code>的区别</h2><ul><li><code>#define</code>是预处理指令，在预处理阶段对宏定义进行分析和替换，而<code>const</code>是关键字，是由编译器在编译阶段处理的</li><li><code>#define</code>没有作用域的限制（但也得在<code>#define</code>后使用啊不然就违反因果律了），宏可以被定义在当前程序的任意位置或者被其包含的头文件中，只有遇到对应的<code>#undef</code>才失效。而<code>const</code>修饰的变量有作用域的限制。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">namespace</span> definePI &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PI 3.1415926</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> pi = <span class="hljs-number">3.1415926</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, PI);      <span class="hljs-comment">// 输出3.1415926</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, pi);      <span class="hljs-comment">// 编译错误</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> PI</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, PI);      <span class="hljs-comment">// 编译错误</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f\n&quot;</span>, E);       <span class="hljs-comment">// 编译错误</span><br>&#125;<br><br><span class="hljs-keyword">namespace</span> defineE &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> E 2.7182818</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><code>#define</code>可以重定义（需要先<code>#undef</code>取消定义）但是<code>const</code>不行  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> X 30</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Y=<span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of X: &quot;</span>&lt;&lt;X&lt;&lt;endl; <span class="hljs-comment">//输出30</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">undef</span> X</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> X 300</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of X: &quot;</span>&lt;&lt;X&lt;&lt;endl; <span class="hljs-comment">//输出300</span><br>    <br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of Y: &quot;</span>&lt;&lt;Y&lt;&lt;endl; <span class="hljs-comment">//输出10</span><br>    Y=<span class="hljs-number">100</span>;<span class="hljs-comment">//error, we can not assign value to const</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;Value of Y: &quot;</span>&lt;&lt;Y&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a><code>constexpr</code></h2><p><code>constexpr</code>在C++11中被引进，字面意思是<code>const expression</code>。<code>constexpr</code>修饰的变量是编译期常量，且必须用常量表达式初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mf = <span class="hljs-number">20</span>;              <span class="hljs-comment">//正确，20是常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> limit = mf + <span class="hljs-number">1</span>;       <span class="hljs-comment">//正确，mf + 1是常量表达式</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> sz = <span class="hljs-built_in">size</span>();         <span class="hljs-comment">//未知，若size()函数是一个constexpr函数时即正确，反之错误。</span><br><br><span class="hljs-type">int</span> i = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> t = i;                <span class="hljs-comment">//错误，i不是常量</span><br></code></pre></td></tr></table></figure><h3 id="literal-type"><a href="#literal-type" class="headerlink" title="literal type"></a><code>literal type</code></h3><p><code>constexpr</code>只能用于修饰<code>literal type</code>的变量，一个变量是<code>literal type</code>当且仅当它属于下面的类型</p><ul><li>标量类型 <a href="https://en.cppreference.com/w/cpp/named_req/ScalarType.html">scalar type</a><br>包含<ul><li>算数类型</li><li>枚举类型</li><li>指针类型</li><li>指向类成员的指针类型</li><li><code>std::nullptr_t</code></li><li>以上类型的<code>cv</code>限定版本（即用<code>const</code>或<code>volatile</code>修饰的版本）</li></ul></li><li>引用</li><li><code>literal type</code>的数组</li><li>具有以下所有性质的<code>cv-qualified</code>类<ul><li>拥有平凡(<code>trivial</code>)析构函数（即默认析构函数）（C++20前的版本）或<code>constexpr</code>析构函数(C++20)</li><li>所有非静态且非<code>variant</code>的成员（<code>variant</code>变量在编译时无法确定变量的具体类型）和基类都不是<code>volatile</code>修饰的<code>literal type</code>, 并且是下面几种类型之一<ul><li><code>lambda</code>类型</li><li>满足下列条件的聚合<code>union</code><ul><li>没有<code>variant</code>成员</li><li>或者至少有一个非<code>volatile</code>修饰的<code>literal type</code>的<code>variant</code>成员</li></ul></li><li>非<code>union</code>的聚合类型，并且每个匿名联合体成员也都满足<ul><li>没有<code>variant</code>成员</li><li>或者至少有一个非<code>volatile</code>修饰的<code>literal type</code>的<code>variant</code>成员</li></ul></li><li>具有至少一个<code>constexpr</code>构造函数的类型，且该构造函数不是拷贝或移动构造函数</li></ul></li></ul></li></ul><h3 id="与const的区别"><a href="#与const的区别" class="headerlink" title="与const的区别"></a>与<code>const</code>的区别</h3><ul><li><code>const</code>修饰的变量可以在运行时才初始化，而<code>constexpr</code>则一定会在编译期初始化。​</li><li>而<code>const</code>表示的是read only的语义，只保证修饰的变量运行时不可以被直接更改，并未区分是编译期常量还是运行期常量。​</li></ul><h3 id="constexpr指针"><a href="#constexpr指针" class="headerlink" title="constexpr指针"></a><code>constexpr</code>指针</h3><p><code>constexpr</code>只对指针本身有效，而不会对指针指向的对象生效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;            <span class="hljs-comment">//正确，p是一个指向整型常量的指针, p本身可以被修改，但是p指向的内存无法通过p来修改</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *q = <span class="hljs-literal">nullptr</span>;        <span class="hljs-comment">//正确，但q是一个指向  整数  的  常量指针，q无法被修改</span><br></code></pre></td></tr></table></figure><p>一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>或者<code>0</code>，或者是指向存储于某个固定地址中的对象。</p><h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a><code>constexpr</code>函数</h3><p><code>constexpr</code>修饰的函数要求其返回类型以及所有的形参都是<code>literal type</code>，且函数体中必须有且仅有一条<code>return</code>语句(除非函数的返回值是<code>void</code>)。这样在它们被调用时，编译期会把它们直接展开替换为结果值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">new_sz</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; &#125;<span class="hljs-comment">//constexpr函数</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> foo = <span class="hljs-built_in">new_sz</span>();<br><span class="hljs-comment">//在对变量foo初始化时，编译器把对constexpr函数的调用替换成其结果值。为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数。</span><br></code></pre></td></tr></table></figure><p>有意思的是，C++允许<code>constexpr</code>返回的值不是常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//如果cnt是常量表达式，则scale(cnt)也是常量表达式</span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">size_t</span> <span class="hljs-title">scale</span><span class="hljs-params">(<span class="hljs-type">size_t</span> cnt)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">new_sz</span>() * cnt; &#125;<br><br><span class="hljs-comment">//当scale的实参是常量表达式时，它的表达式也是常量表达式，反之则不然</span><br><span class="hljs-type">int</span> arr[<span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>)];<span class="hljs-comment">//正确：scale(2)是常量表达式</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;<span class="hljs-comment">//i不是常量表达式</span><br><span class="hljs-type">int</span> a2[<span class="hljs-built_in">scale</span>(i)];<span class="hljs-comment">//错误：scale(i)不是常量表达式</span><br></code></pre></td></tr></table></figure><p>前面提到返回值类型为<code>void</code>的函数也可以用<code>constexpr</code>来修饰，乍一看这样的函数没有任何意义，但实际上<code>constexpr</code>修饰的函数除了返回值是编译期常量外，还在编译期运行，这样就能在编译期执行一些操作。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>数组大小、模板参数和<code>switch</code>语句都要求编译期常量，使用<code>constexpr</code>修饰的变量或函数可以用于这些场景。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> cn = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> arr[n]; <span class="hljs-comment">//正确</span><br><span class="hljs-type">int</span> arr[cn]; <span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html">[RUNOOB] C++ const 关键字小结</a></li><li><a href="https://www.runoob.com/w3cnote/c-volatile-keyword.html">[RUNOOB] C&#x2F;C++ 中 volatile 关键字详解</a></li><li><a href="https://en.cppreference.com/w/cpp/keyword/const.html">[cppreference.com] C++ keyword: const</a></li><li><a href="https://en.cppreference.com/w/cpp/language/cv.html">[cppreference.com] cv (const and volatile) type qualifiers</a></li><li><a href="https://en.cppreference.com/w/cpp/keyword/volatile.html">[cppreference.com] C++ keyword: volatile</a></li><li><a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">[cppreference.com] C++ named requirements: LiteralType (since C++11)</a></li><li><a href="https://www.cnblogs.com/ljwgis/p/13095739.html">[cnblog] C++11新特性：constexpr变量和constexpr函数</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的inline关键字</title>
    <link href="/2025/06/08/cpp-inline/"/>
    <url>/2025/06/08/cpp-inline/</url>
    
    <content type="html"><![CDATA[<p><code>inline</code>关键字会向编译器发出一个请求（而非命令，编译器可以选择拒绝），建议将函数体在调用点处内联展开，以减少函数的调用开销（例如栈帧的创建、参数的传递等）。</p><ul><li><code>inline</code>函数通常用于执行速度快且调用频繁的小函数</li><li><code>inline</code>函数的定义通常放在头文件中</li><li><code>inline</code>函数不能包含复杂的控制结构，例如循环和递归</li><li>编译器可能会忽略<code>inline</code>关键字，一般是<ul><li>函数体较大</li><li>包含复杂逻辑</li><li>编译器的优化级别较低，在编译时比较保守</li><li>编译器的优化策略决定</li></ul></li><li>可以通过在汇编代码查看代码是否内联，被内联的函数不会有函数标签</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的内存管理</title>
    <link href="/2025/06/07/memory/"/>
    <url>/2025/06/07/memory/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>栈内存是由<strong>编译器自动管理</strong>的内存区域，用于存储局部变量、函数参数和返回地址等。栈内存的分配和释放是自动进行的：</p><ul><li>当函数被调用时，局部变量和参数会被压入栈中</li><li>当函数返回时，这些局部变量和参数会被弹出栈并释放。<br>栈内存的大小固定，一般为8M左右，无法动态调整。作用域一般是函数内部，函数返回时会自动释放。</li></ul><p>分配速度快。</p><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>栈溢出最典型的情况就是无限递归调用导致溢出，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">func</span>(); <span class="hljs-comment">// 无限递归调用</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="返回地址与栈攻击"><a href="#返回地址与栈攻击" class="headerlink" title="返回地址与栈攻击"></a>返回地址与栈攻击</h4><p>在函数调用过程中，当前函数执行完成后应返回调用者的位置，这个位置称之为返回地址。</p><p>由于返回地址是由编译器自动管理的，其在栈内存上往往与编译器为函数内局部变量分配的内存相邻，因此攻击者可以利用这一特性，向固定大小的缓冲区写入超长的数据，覆盖返回地址，使程序跳转到提前布置好的恶意代码，这是一种典型的栈溢出攻击。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vulnerable</span><span class="hljs-params">(<span class="hljs-type">char</span> *input)</span> </span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">16</span>];<br>    <span class="hljs-built_in">strcpy</span>(buf, input); <span class="hljs-comment">// 无边界检查,如果输入超过16字节，就可能覆盖返回地址，跳转到攻击者布置的shellcode。</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>堆内存是由程序员手动管理的内存区域。大小不固定，可以动态调整，但任意出现内存泄露等问题。</p><p>作用域由程序员控制，只要不释放内存就一直存在。</p><p>与栈内存相比分配速度较慢。</p><h3 id="变量和存储区"><a href="#变量和存储区" class="headerlink" title="变量和存储区"></a>变量和存储区</h3><img src="/2025/06/07/memory/memory.jpg" class="" title="C++的内存分区"><p>c++程序的内存分为4个区域</p><ul><li><strong>代码段</strong> 存储代码的指令，只读</li><li><strong>数据段</strong><br>存储<strong>全局变量</strong>和<strong>静态变量</strong>，分为 <ul><li><p>已初始化的数据区<br>进一步分为</p><ul><li>已初始化的只读区域<br>存储<code>const</code>修饰的全局变量、常量字符串等，例如<code>const char* str = &quot;hello world&quot;</code>这行代码中<code>&quot;hello world&quot;</code>存储在已初始化的只读区域，<code>str</code>放在已初始化的读写区域(注意<code>const char* str</code>是 “指向常量的指针”，所以它<code>str</code>还可以修改，只是不能通过它去修改指向的内容。)</li><li>已初始化的读写区域</li></ul></li><li><p>未初始化的数据区（Block Started by Symbol，BSS）<br>存储未初始化或初始化为0的全局变量和静态变量</p></li></ul></li><li><strong>堆区</strong></li><li><strong>栈区</strong></li></ul><h3 id="内存泄露与悬空指针"><a href="#内存泄露与悬空指针" class="headerlink" title="内存泄露与悬空指针"></a>内存泄露与悬空指针</h3><ul><li>内存泄漏指的是程序没有主动释放不再使用的内存，导致内存的占用不断增加。为了防止内存泄露，需要在不再使用内存时将其及时释放。</li><li>悬空指针指的则是指向了已经释放的内存的指针，<strong>为了避免悬空指针，应该在释放内存后，将指向它的指针置为<code>nullptr</code></strong></li></ul><h2 id="堆内存的使用"><a href="#堆内存的使用" class="headerlink" title="堆内存的使用"></a>堆内存的使用</h2><h3 id="malloc和free"><a href="#malloc和free" class="headerlink" title="malloc和free"></a><code>malloc</code>和<code>free</code></h3><ul><li><a href="https://en.cppreference.com/w/cpp/memory/c/malloc">std::malloc</a><br>用于在堆上分配指定大小的内存块  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure>返回指向分配的内存的指针，若分配失败，则返回<code>nullptr</code></li><li><code>calloc</code><br>分配内存并初始化（将所有的字节都置0）   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> num, <span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure><ul><li><code>num</code>要分配的元素的个数</li><li><code>size</code>元素的大小（字节数）</li></ul></li><li><code>realloc</code><br>调整已分配的内存块的大小   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> size)</span></span>; <br></code></pre></td></tr></table></figure><ul><li><code>ptr</code>要调整的内存块的指针</li><li><code>size</code>新的内存块大小（字节数）</li><li>返回指向新的内存块的指针，若分配失败，返回<code>nullptr</code>，原来的内存块（<code>ptr</code>）保持原样。<ul><li><p>分配失败可能会导致内存泄露</p><blockquote><p>If there is not enough memory, the old memory block is not freed and null pointer is returned.——<a href="https://en.cppreference.com/w/c/memory/realloc">cppreference</a></p></blockquote><p>需要手动处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++">        <span class="hljs-type">int</span>* ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>`(<span class="hljs-type">int</span>) * <span class="hljs-number">10</span>);​<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>) &#123;​<br>    <span class="hljs-comment">// 处理内存分配失败​</span><br>    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 或采取其他错误处理​</span><br>&#125;​<br>​<br><span class="hljs-comment">// 使用临时指针保存realloc结果​</span><br><span class="hljs-type">int</span>* temp = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">realloc</span>(ptr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">20</span>);​<br><span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>) &#123;​<br>    <span class="hljs-comment">// realloc失败：原始内存仍可通过ptr访问​</span><br>    <span class="hljs-built_in">free</span>(ptr);   <span class="hljs-comment">// 释放原始内存（可选）​</span><br>    ptr = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 避免悬空指针​</span><br>    <span class="hljs-comment">// 处理错误（例如退出或降级使用）​</span><br>&#125; <span class="hljs-keyword">else</span> &#123;​<br>    ptr = temp; <span class="hljs-comment">// realloc成功，更新ptr​</span><br>    <span class="hljs-comment">// 现在ptr指向20个int的内存​</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><code>free</code><br>释放通过<code>malloc</code>,<code>calloc</code>和<code>realloc</code>分配的内存空间  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢"><a href="#为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢" class="headerlink" title="为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢?"></a>为什么malloc时候需要传递长度信息，而free时候却不需要传递长度信息呢?</h4><p>因为<code>malloc(size)</code>在分配内存时，除了会分配一部分大小为<code>size</code>的内存供程序员使用外，还会在这部分内存头部添加这块内存的元数据，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mem_control_block</span> &#123;<br>  <span class="hljs-type">int</span> is_available; <br>  <span class="hljs-type">int</span> size;        <br>&#125;;<br></code></pre></td></tr></table></figure><p>这样<code>free</code>这块内存的时候就可以访问这块区域进而获取需要free的内存大小。</p><!-- #### malloc的底层实现 --><h3 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a><code>new</code>和<code>delete</code></h3><ul><li><code>new</code>用于在堆上分配内存，并触发对象的构造函数，返回指向这块内存的指针</li><li><code>delete</code>则会触发对象的析构函数，并释放由<code>new</code>分配的内存</li><li><code>new[]</code>用于在堆上分配数组内存</li><li><code>delete[]</code>用于释放<code>new[]</code>分配的内存</li><li><code>new</code>和<code>delet</code>，<code>new[]</code>和<code>delete[]</code>需要配对使用，否则会导致未定义行为</li><li><code>placement new</code>允许在已分配的内存上构造对象，而不会分配新的内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br>​<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;​<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> a): <span class="hljs-built_in">a_</span>(a) &#123;&#125;​<br>​<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;​<br>        std::cout &lt;&lt; a_ &lt;&lt; std::endl;​<br>    &#125;​<br>    <span class="hljs-type">int</span> a_;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-type">char</span>* buffer = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)];​<br>​    <br>    A* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">9</span>);<br>    <span class="hljs-comment">// placement new在 buffer 上构造 A 对象​</span><br>    A* p1 = <span class="hljs-built_in">new</span> (buffer) <span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>);​<br>    p1-&gt;<span class="hljs-built_in">print</span>();​<br>​<br>    <span class="hljs-comment">// 显式调用析构函数​</span><br>    p1-&gt;~<span class="hljs-built_in">A</span>();​<br>​<br>    <span class="hljs-comment">// 释放内存​</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">delete</span>[] buffer;​<br>    p = <span class="hljs-literal">nullptr</span>;<br>    buffer = <span class="hljs-literal">nullptr</span>;<br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="new和delete的实现"><a href="#new和delete的实现" class="headerlink" title="new和delete的实现"></a><code>new</code>和<code>delete</code>的实现</h4><p>在上面的代码中，<code>A * p = new A(9)</code>包含下面的步骤</p><ul><li>调用C++标准库<strong>函数</strong><code>operator new</code>(如果是<code>new []</code>则调用的是<code>operator new []</code>)为<code>A</code>分配一块原始的内存</li><li>调用<code>A</code>的构造函数，在这块内存上构造对象</li><li>返回指向刚刚构造的<code>A</code>对象的指针</li></ul><p>需要注意的是，如果类<code>A</code>重载了<code>operator new</code>，则会调用<code>A::operator new(size_t size)</code>，否则调用全局函数<code>::operator new(size_t size)</code>。</p><p>运行<code>delete p</code>时，则会进行下面的操作</p><ul><li>调用<code>p</code>指向对象的析构函数</li><li>调用C++标准库<strong>函数</strong><code>operator delete</code>来释放该对象的内存，传入其的参数为<code>p</code>的值，即对象的地址。</li></ul><p><code>operator new</code>和<code>operator delete</code>的函数原型如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-type">size_t</span>)</span></span>;     <span class="hljs-comment">//allocate an object</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span>;    <span class="hljs-comment">//free an object</span><br><br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-type">size_t</span>);     <span class="hljs-comment">//allocate an array</span><br><span class="hljs-type">void</span> *<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-type">void</span> *);    <span class="hljs-comment">//free an array</span><br></code></pre></td></tr></table></figure><h4 id="new-和delete-的实现"><a href="#new-和delete-的实现" class="headerlink" title="new []和delete []的实现"></a><code>new []</code>和<code>delete []</code>的实现</h4><p>与<code>new</code>和<code>delete</code>类似，<code>new []</code>和<code>delete []</code>会分别调用<code>operator new []</code>和<code>operator delete []</code>来分配和释放内存。<code>new[]</code>会调用类的构造函数依次构造数组中的每个对象，<code>delete []</code>则会调用析构函数依次将所有的对象析构。</p><p>与<code>new</code>和<code>delete</code>不同的是，<code>new []</code>在为数组分配空间时，会额外分配4字节的空间来保存数组的长度，这4个字节会放在数组内存的前面，在调用<code>delete []</code>就会读取这4个字节以确定数组的长度。</p><p>因此<code>void * operator delete[] (void *)</code>接受的参数不是指向数组的指针，而是指向数组的指针减4个字节的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">string *ps = <span class="hljs-keyword">new</span> string[<span class="hljs-number">10</span>];<br><span class="hljs-keyword">delete</span> [] ps;<br></code></pre></td></tr></table></figure><p>以上面的代码为例，<code>delete [] ps</code>调用<code>operator delete[] (void *)</code>时，传入<code>operator delete[]</code>的参数不是<code>ps</code>而是<code>ps</code>的值减4(前移4字节，而不是<code>ps-4</code>，前移4个<code>string</code>的大小)。</p><p>对于不需要调用析构函数的对象（例如<code>int</code>等内置类型），<code>new[]</code>时不会额外多分配4个字节，<code>delete []</code>直接调用<code>operator delete[]</code>，传入的地址也不用前移4个字节，因此如果是用<code>new[]</code>分配内置类型的数组，是可以使用<code>delete</code>来释放的。</p><h4 id="new-和delete-不配对使用的后果"><a href="#new-和delete-不配对使用的后果" class="headerlink" title="new[]和delete[]不配对使用的后果"></a><code>new[]</code>和<code>delete[]</code>不配对使用的后果</h4><h5 id="1-new-和delete配对使用"><a href="#1-new-和delete配对使用" class="headerlink" title="1. new[]和delete配对使用"></a>1. <code>new[]</code>和<code>delete</code>配对使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span> &#123;​<br>  <span class="hljs-keyword">public</span>:​<br>  <span class="hljs-built_in">inner</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Constructing&quot;</span> &lt;&lt; endl; &#125;​<br>  ~<span class="hljs-built_in">inner</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Destructing&quot;</span> &lt;&lt; endl; &#125;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;​<br>  inner *p = <span class="hljs-keyword">new</span> inner[<span class="hljs-number">2</span>];​<br>  <span class="hljs-keyword">delete</span> p;​<br>  p = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br>​<span class="hljs-comment">/*</span><br><span class="hljs-comment">程序输出：​</span><br><span class="hljs-comment">Constructing​</span><br><span class="hljs-comment">Constructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">munmap_chunk(): invalid pointer​</span><br><span class="hljs-comment">Aborted (core dumped)</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>程序在调用了1次析构函数后挂掉。这是因为<code>delete</code>不会访问<code>p</code>的前4个字节获取长度，只调用了1次析构函数。并且<code>delete</code>传入<code>operator delete</code>的参数是<code>p</code>而不是<code>p</code>的值减4，而<code>p</code>的值减4才是一块内存的起始地址，释放内存时不从起始地址开始会出现段错误，从而导致程序整个挂掉</p><h5 id="2-new和delete-配对使用"><a href="#2-new和delete-配对使用" class="headerlink" title="2. new和delete[]配对使用"></a>2. <code>new</code>和<code>delete[]</code>配对使用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span>​</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>​</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;​<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">inner</span> &#123;​<br>  <span class="hljs-keyword">public</span>:​<br>  <span class="hljs-built_in">inner</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Constructing&quot;</span> &lt;&lt; endl; &#125;​<br>  ~<span class="hljs-built_in">inner</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Destructing&quot;</span> &lt;&lt; endl; &#125;​<br>&#125;;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;​<br>  inner *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">inner</span>();​<br>  <span class="hljs-keyword">delete</span> []p;​<br>  p = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br>​<span class="hljs-comment">/*</span><br><span class="hljs-comment">程序输出：​</span><br><span class="hljs-comment">Constructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">...​</span><br><span class="hljs-comment">Destructing​</span><br><span class="hljs-comment">free(): invalid pointer​</span><br><span class="hljs-comment">Aborted (core dumped)​</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>程序调用了<strong>不定次数</strong>的析构函数然后挂掉。这是因为<code>delete [] p</code>会往前4个字节去取数组的长度，而<code>new</code>并没有申请这4个字节的内存，因此这4个字节的内容是未知的，进而导致调用析构函数的次数是未知的。最后释放内存时使用的地址也是<code>p</code>的值减4而非正确的起始地址<code>p</code>，进而导致程序挂掉。</p><h3 id="malloc和new的区别"><a href="#malloc和new的区别" class="headerlink" title="malloc和new的区别"></a><code>malloc</code>和<code>new</code>的区别</h3><ul><li><code>malloc</code>是C的库函数而<code>new</code>是C++运算符</li><li><code>malloc</code>返回<code>void *</code>，而<code>new</code>返回具体类型的指针</li><li>内存分配失败时，<code>malloc</code>返回<code>NULL</code>而<code>new</code>则会抛出<code>std::bad_alloc</code>异常</li><li><code>malloc</code>在使用时需要手动计算内存大小，而<code>new</code>不需要</li><li><code>new</code>会调用构造函数，而<code>malloc</code>不会</li><li><code>new</code>可以重载（可以重载<code>operator new</code>而非<code>new operator</code>），而<code>malloc</code>不行</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C++中的指针</title>
    <link href="/2025/06/06/cpp-pointer/"/>
    <url>/2025/06/06/cpp-pointer/</url>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>指针本质上也是一种变量，不过它存储的是对应变量类型的地址。</p><h3 id="为什么要有指针"><a href="#为什么要有指针" class="headerlink" title="为什么要有指针"></a>为什么要有指针</h3><!-- 笔者在学习指针时，一直有一个疑惑，那就是变量本身就包含地址，那为什么还需要指针呢？想来如果解释了这个问题，就解释了指针在C++中发挥的作用。* 首先, 我们拿到地址后，我们可以用地址做什么？  * 修改这个地址对应内存的值  似乎有些脱裤子放屁了，用变量本身就可以做到  * 对于一些很大的变量（类和结构体），值传递会有很大的复制开销，我们可以通过传递地址来减少这部分开销。  * 我们可以通过地址，访问邻近的变量*  --><p>之所以要有指针，是因为虽然变量本身就包含了地址的信息（不然我们也没法通过<code>&amp;</code>来取址），但变量和其地址之间的关系是一一对应的且无法修改的，无法满足我们对地址本身进行处理的需求。例如如果我们要实现数组的数据结构，将数据放入连续的内存中，那么我们需要解决下面的问题</p><ol><li>这块连续内存的起始地址是什么？</li><li>访问数组中的某个元素时，我们该如何确定它的地址？<br>假如这个元素的索引是<code>i</code>，数组中的元素大小都是<code>T</code>，那么我们访问它的时候就需要通过<code>首地址+i*T</code>来获取它的地址。</li></ol><p>那么问题来了，地址本身是个整型数据，为什么我们不直接使用<code>int</code>等整型类型来存储和操作呢？</p><ul><li>首先，需要维护一个额外的变量来告诉我们这个地址对应的变量大小，否则我们没法对这个地址取值，也没办法进行前面提到的数组寻址操作</li><li>其次，这样写的代码可读性很差</li><li>再者，不同平台的地址大小不同，如果我们在32位系统中使用<code>int</code>来存储地址，那么这部分代码就无法在64位的系统中运行<br>因此，定义一种新的变量来存储和操作地址是很有必要的。</li></ul><h3 id="指针的基本操作"><a href="#指针的基本操作" class="headerlink" title="指针的基本操作"></a>指针的基本操作</h3><ul><li>赋值和初始化  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* p = &amp;a; <br></code></pre></td></tr></table></figure></li><li>解引用<br>指针通过<code>*</code>操作符获取指向的内存中存储的值，值的类型由指针的类型确定</li><li>指针运算<ul><li>加减运算<ul><li><code>T*</code>类型的指针<code>p + i</code>相当于<code>p</code>向前移动了<code>i * sizeof(T)</code>个字节</li><li>支持<code>++</code>和<code>--</code></li></ul></li><li>比较运算<br>比较两个指针的值，也就是比较两个地址是否相同</li></ul></li></ul><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><p>数组名本质是指向数组首地址的、<strong>不可修改</strong>的常量指针。在作为函数参数时，它会退化为指向数组首元素的指针，这时候可以对它进行自增等运算。</p><ul><li><code>int (*p)[10]</code>表示这是一个指向长度为10的<code>int</code>数组的指针，其类型为<code>int (*)[]</code>。也就是说<code>p++</code>会令<code>p</code>向前移动40个字节</li><li><code>int *p[10]</code>表示这是一个包含了10个<code>int*</code>变量的数组。作为函数参数退化为指针后，它的类型是<code>int**</code></li></ul><!-- ### 指针与动态数组 --><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>每个函数都有一个唯一的入口地址，函数指针存储的就是这个地址。</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//返回类型 (*指针名)(函数参数列表);</span><br><span class="hljs-built_in">int</span> (*funcPtr)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>这里的<code>funcPtr</code>就是一个指向函数的指针，接受两个<code>int</code>参数并返回<code>int</code>值。</p><h3 id="赋值与调用"><a href="#赋值与调用" class="headerlink" title="赋值与调用"></a>赋值与调用</h3><ul><li>函数名在大多数情况下都会被编译器解释为函数的地址，因此可以直接用函数名给函数指针赋值。</li><li>函数指针的调用方式与函数名的调用方式一致</li><li>基于提高可读性的目的，可以使用<code>typedef</code>来封装函数指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;​<br>    <span class="hljs-keyword">return</span> a + b;​<br>&#125;​<br>​<br><span class="hljs-comment">// 封装后的函数指针类型​</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(*FuncPtr)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;​<br>​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-comment">// 声明一个函数指针变量​</span><br>    FuncPtr fp = add;​<br>​<br>    <span class="hljs-comment">// 通过函数指针调用函数​</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">fp</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);​<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Result: %d\n&quot;</span>, result);  <span class="hljs-comment">// 输出: Result: 7​</span><br>​<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;​<br></code></pre></td></tr></table></figure><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>指针函数是返回指针的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;<br></code></pre></td></tr></table></figure><p>注意和函数指针的区别在于是否有括号将*+标识符包裹起来，关于C&#x2F;C++中的声明规则，可以阅读<a href="https://cseweb.ucsd.edu/~gbournou/CSE131/rt_lt.rule.html">C Right-Left Rule (Rick Ord’s CSE 131</a></p><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>通过回调函数，程序在运行时可以动态地决定调用哪个函数。这常常用于事件处理和异步编程的场景中，例如GUI编程中的按钮和ROS中对topic的订阅都会绑定对应的回调函数。在C语言中，回调函数通过函数指针来实现。</p><h4 id="回调函数的实现"><a href="#回调函数的实现" class="headerlink" title="回调函数的实现"></a>回调函数的实现</h4><ol><li>设计包含回调函数参数的函数接口</li><li>调用1.中的函数并传递合适的回调函数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">process</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, FuncPtr callback)</span> </span>&#123;​<br>    <span class="hljs-comment">// ... 执行一些操作 ...​</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">callback</span>(x, y);​<br>    <span class="hljs-comment">// ... 使用回调函数的返回值进行进一步处理 ...​</span><br>&#125;​<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;​<br>    <span class="hljs-built_in">process</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, add);​ <span class="hljs-comment">//可以传递div,multi等等函数，只要函数的参数和返回值与函数指针一致即可</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;​<br>&#125;<br></code></pre></td></tr></table></figure><!-- ## 指针与内存管理https://lb3fn675fh.feishu.cn/wiki/OVsewICczis2jlkKBgKc3Mz9n8d## 指针与高级数据类型https://lb3fn675fh.feishu.cn/wiki/QlEJwXrH4i9MxPkS1OncaPX4nze## 指针与常量https://lb3fn675fh.feishu.cn/wiki/WcSrwytf5ivjkQkWd86cEJnxnph --><h2 id="void"><a href="#void" class="headerlink" title="void *"></a><code>void *</code></h2><ul><li>任何类型的指针都可以直接赋值给<code>void</code>指针，且无需进行强制类型转换</li><li>而<code>void</code>指针不能直接赋值给其它指针，必须进行显示类型转换</li><li><code>void</code>指针可以和其他指针比较存放的地址是否相同</li><li><code>void</code>指针只有在进行强制类型转换后才可以对其进行正常的指针操作</li></ul><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ul><li>避免野指针：始终确保指针在使用前已经正确初始化，并且在不再需要时将其设置为<code>nullptr</code>。</li><li>避免内存泄漏：动态分配的内存在使用完毕后一定要使用<code>free</code>释放。</li><li>有效性检查：在解引用前检查它是否是<code>nullptr</code>。</li><li>使用智能指针：C++11引入的智能指针可以自动管理内存，减少内存泄露的风险。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
